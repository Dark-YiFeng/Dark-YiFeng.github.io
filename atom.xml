<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dark-yifeng.github.io</id>
    <title>Dark</title>
    <updated>2020-05-18T09:45:38.882Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dark-yifeng.github.io"/>
    <link rel="self" href="https://dark-yifeng.github.io/atom.xml"/>
    <subtitle>克己，执着，努力，疯狂，谦卑</subtitle>
    <logo>https://dark-yifeng.github.io/images/avatar.png</logo>
    <icon>https://dark-yifeng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Dark</rights>
    <entry>
        <title type="html"><![CDATA[Vue：15个最佳做法]]></title>
        <id>https://dark-yifeng.github.io/post/vue-de-mo-ban-bian-yi-yuan-li/</id>
        <link href="https://dark-yifeng.github.io/post/vue-de-mo-ban-bian-yi-yuan-li/">
        </link>
        <updated>2020-05-18T09:37:57.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E5%A7%8B%E7%BB%88%E5%9C%A8-v-for-%E4%B8%AD%E4%BD%BF%E7%94%A8-key">1.始终在 v-for 中使用 :key</a></li>
<li><a href="#2%E5%9C%A8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D">2.在事件中使用短横线命名</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A3%B0%E6%98%8E-props%E5%B9%B6%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D%E6%9D%A5%E8%AE%BF%E9%97%AE-props">3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props</a></li>
<li><a href="#4data-%E5%BA%94%E5%A7%8B%E7%BB%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">4.data 应始终返回一个函数</a></li>
<li><a href="#5-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%90%8C%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8A%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-for%E6%8C%87%E4%BB%A4">5. 不要在同个元素上同时使用v-if和v-for指令</a></li>
<li><a href="#6%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%88%91%E4%BB%AC%E7%9A%84-props">6.用正确的定义验证我们的 props</a></li>
<li><a href="#7%E7%BB%84%E4%BB%B6%E5%85%A8%E5%90%8D%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E6%88%96%E6%88%96%E8%80%85%E7%9F%AD%E6%A8%AA%E7%BA%BF">7.组件全名使用驼峰或或者短横线</a></li>
<li><a href="#8-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E7%9B%B8%E5%BA%94%E5%9C%B0%E5%8A%A0%E4%B8%8A%E5%89%8D%E7%BC%80">8. 基本组件应该相应地加上前缀</a></li>
<li><a href="#9%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D%E5%BA%94%E8%AF%A5%E5%B8%A6%E6%9C%89%E5%89%8D%E7%BC%80-the">9.单实例组件命名应该带有前缀 The</a></li>
<li><a href="#10%E4%BF%9D%E6%8C%81%E6%8C%87%E4%BB%A4%E7%AE%80%E5%86%99%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">10.保持指令简写的一致性</a></li>
<li><a href="#11%E4%B8%8D%E8%A6%81%E5%9C%A8created%E5%92%8Cwatch%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">11.不要在“created”和“watch”中调用方法</a></li>
<li><a href="#12-%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E8%AF%A5%E5%8F%AA%E6%9C%89%E5%9F%BA%E6%9C%AC%E7%9A%84-js-%E8%A1%A8%E8%BE%BE%E5%BC%8F">12. 模板表达式应该只有基本的 JS 表达式</a></li>
<li><a href="#13%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%9B%B4%E6%96%B0">13.路由参数变化组件不更新</a></li>
<li><a href="#14%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD">14.路由懒加载</a></li>
<li><a href="#15%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D">15.自定义路径别名</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1始终在-v-for-中使用-key">1.始终在 v-for 中使用 :key</h2>
<p>在需要操纵数据时，将key属性与v-for指令一起使用可以让程序保持恒定且可预测。</p>
<p>这是很有必要的，这样Vue就可以跟踪组件状态，并对不同的元素有一个常量引用。在使用动画或Vue转换时，key 非常有用。</p>
<p>如果没有key ，Vue只会尝试使DOM尽可能高效。 这可能意味着v-for中的元素可能会出现乱序，或者它们的行为难以预测。 如果我们对每个元素都有唯一的键引用，那么我们可以更好地预测Vue应用程序将如何精确地处理DOM操作。</p>
<h2 id="2在事件中使用短横线命名">2.在事件中使用短横线命名</h2>
<p>在发出定制事件时，最好使用短横线命名，这是因为在父组件中，我们使用相同的语法来侦听该事件。</p>
<p>因此，为了确保我们各组件之间的一致性，并使您的代码更具可读性，请在两个地方都坚持使用短横线命名。</p>
<pre><code class="language-c">this.$emit('close-window')
// 在父组件中
&lt;popup-window @close-window='handleEvent()' /&gt;
</code></pre>
<h2 id="3使用驼峰式声明-props并在模板中使用短横线命名来访问-props">3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props</h2>
<p>最佳做法只是遵循每种语言的约定。 在 JS 中，驼峰式声明是标准，在HTML中，是短横线命名。 因此，我们相应地使用它们。</p>
<p>幸运的是，Vue 已经提供了驼峰式声明和短横线命名之间转换，因此除了实际声明它们之外，我们不必担心任何事情。</p>
<pre><code class="language-c">// 不好的做法
&lt;PopupWindow titleText='hello world' /&gt; 
props: { 'title-text': String }
// 好的做法
&lt;PopupWindow title-text='hello world' /&gt; 
props: { titleText: String }
</code></pre>
<h2 id="4data-应始终返回一个函数">4.data 应始终返回一个函数</h2>
<p>声明组件data时，data选项应始终返回一个函数。 如果返回的是一个对象，那么该data将在组件的所有实例之间共享。</p>
<pre><code class="language-c">// 不好的做法
data: {
  name: 'My Window',
  articles: []
}
</code></pre>
<p>但是，大多数情况下，我们的目标是构建可重用的组件，因此我们希望每个组件返回一个惟一的对象。我们通过在函数中返回数据对象来实现这一点。</p>
<pre><code class="language-c">// 好的做法
data () {
  return {
    name: 'My Window',
    articles: []
  }
}
</code></pre>
<h2 id="5-不要在同个元素上同时使用v-if和v-for指令">5. 不要在同个元素上同时使用v-if和v-for指令</h2>
<p>为了过滤数组中的元素，我们很容易将v-if与v-for在同个元素同时使用。</p>
<pre><code class="language-c">// 不好的做法
&lt;div v-for='product in products' v-if='product.price &lt; 500'&gt;
问题是在 Vue 优先使用v-for指令，而不是v-if指令。它循环遍历每个元素，然后检查v-if条件。

this.products.map(function (product) {
  if (product.price &lt; 500) {
    return product
  }
})
</code></pre>
<p>这意味着，即使我们只想渲染列表中的几个元素，也必须遍历整个数组。</p>
<p>这对我们来当然没有任何好处。</p>
<p>一个更聪明的解决方案是遍历一个计算属性，可以把上面的例子重构成下面这样的：</p>
<pre><code class="language-c">&lt;div v-for='product in cheapProducts'&gt;
 
computed: {
  cheapProducts: () =&gt; {
    return this.products.filter(function (product) {
      return product.price &lt; 100
    })
  }
}
</code></pre>
<p>这么做有几个好处：</p>
<p>1.渲染效率更高，因为我们不会遍历所有元素。</p>
<p>2.仅当依赖项更改时，才会重使用过滤后的列表。</p>
<p>3.这写法有助于将组件逻辑从模板中分离出来，使组件更具可读性。</p>
<h2 id="6用正确的定义验证我们的-props">6.用正确的定义验证我们的 props</h2>
<p>这条是很重要，为什么？</p>
<p>在设计大型项目时，很容易忘记用于props的确切格式、类型和其他约定。如果你在一个更大的开发团队中，你的同事不会读心术，所以你要清楚地告诉他们如何使用你的组件。</p>
<p>因此，我们只需编写props验证即可，不必费力地跟踪组件来确定props的格式。</p>
<p>从Vue文档中查看此示例。</p>
<pre><code class="language-c">props: {
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].indexOf(value) !== -1
    }
  }
}
</code></pre>
<h2 id="7组件全名使用驼峰或或者短横线">7.组件全名使用驼峰或或者短横线</h2>
<p>组件的通用命名约定是使用驼峰或短横线。无论我们使用哪个，最重要的是始终保持一致。我认为驼峰方式 效果最好，因为大多数IDE自动完成功能都支持它。</p>
<pre><code class="language-c"># 不好的做法
mycomponent.vue
myComponent.vue
Mycomponent.vue
# 好做法
MyComponent.vue
</code></pre>
<h2 id="8-基本组件应该相应地加上前缀">8. 基本组件应该相应地加上前缀</h2>
<p>根据Vue样式指南，基本组件是仅包含以下内容的组件：</p>
<p>1.HTML 元素。<br>
2.额外的基础组件。<br>
3.第三方的UI组件。</p>
<p>为这些组件命名的最佳实践是为它们提供前缀Base、V或App。同样，只要我们在整个项目中保持一致，可以使用其中任何一种。</p>
<p>BaseButton.vue<br>
BaseIcon.vue<br>
BaseHeading.vue</p>
<p>该命名约定的目的是使基本组件按字母顺序分组在文件系统中。 另外，通过使用webpack导入功能，我们可以搜索与命名约定模式匹配的组件，并将所有组件自动导入为Vue项目中的全局变量。</p>
<h2 id="9单实例组件命名应该带有前缀-the">9.单实例组件命名应该带有前缀 The</h2>
<p>与基本组件类似，单实例组件(每个页面使用一次，不接受任何prop)应该有自己的命名约定。这些组件特定于我们的应用，通常是 footer，header或sider。</p>
<p>该组件只能有一个激活实例。</p>
<p>TheHeader.vue<br>
TheFooter.vue<br>
TheSidebar.vue<br>
ThePopup.vue</p>
<h2 id="10保持指令简写的一致性">10.保持指令简写的一致性</h2>
<p>在Vue开发人员中，一种常见的技术是使用指令的简写。例如：<br>
<br>
@是v-on的简写<br>
: 是 v-bind 的简写<br>
# 是 v-slot 的简写</p>
<p>在vue项目中使用这些缩写是很好的。但是要在整个项目中创建某种约定，总是使用它们或从不使用它们,会使我们的项目更具内聚性和可读性。</p>
<h2 id="11不要在created和watch中调用方法">11.不要在“created”和“watch”中调用方法</h2>
<p>Vue开发人员经常犯的一个错误是他们不必要地在created和watch中调用方法。 其背后的想法是，我们希望在组件初始化后立即运行watch。</p>
<pre><code class="language-c">// 不好的做法
created: () {
this.handleChange()
},
methods: {
handleChange() {
// stuff happens
}
},
watch () {
property() {
this.handleChange()
}
}
</code></pre>
<p>但是，Vue为此提供了内置的解决方案，这是我们经常忘记的Vue watch属性。</p>
<p>我们要做的就是稍微重组watch并声明两个属性：</p>
<p>1.handler (newVal, oldVal)-这是我们的watch方法本身。<br>
2. immediate: true– 代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行</p>
<pre><code class="language-c">// 好的做法
methods: {
  handleChange() {
    // stuff happens
  }
},
watch () {
  property {
    immediate: true
    handler() {
      this.handleChange()
    }
  }
}
</code></pre>
<h2 id="12-模板表达式应该只有基本的-js-表达式">12. 模板表达式应该只有基本的 JS 表达式</h2>
<p>在模板中添加尽可能多的内联功能是很自然的。但是这使得我们的模板不那么具有声明性，而且更加复杂，也让模板会变得非常混乱。</p>
<p>为此，让我们看看Vue样式指南中另一个规范化字符串的示例，看看它有多混乱。</p>
<pre><code class="language-c">//不好的做法
{{
  fullName.split(' ').map(function (word) {
    return word[0].toUpperCase() + word.slice(1)
  }).join(' ')
}}
</code></pre>
<p>基本上，我们希望模板中的所有内容都直观明了。 为了保持这一点，我们应该将复杂的表达式重构为适当命名的组件选项。</p>
<p>分离复杂表达式的另一个好处是可以重用这些值。</p>
<pre><code class="language-c">// 好的做法
{{ normalizedFullName }}
// The complex expression has been moved to a computed property
computed: {
  normalizedFullName: function () {
    return this.fullName.split(' ').map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
    }).join(' ')
  }
}
</code></pre>
<h2 id="13路由参数变化组件不更新">13.路由参数变化组件不更新</h2>
<p>同一 path 的页面跳转时路由参数变化，但是组件没有对应的更新。</p>
<p>原因：主要是因为获取参数写在了created 或者 mounted 路由钩子函数中，路由参数变化的时候，这个生命周期不会重新执行。</p>
<p>我们可以用watch 监听路由。</p>
<pre><code class="language-c">watch: {
 // 方法1  监听路由是否变化
  '$route' (to, from) { 
    if(to.query.id !== from.query.id){
    　　this.id = to.query.id;
    　　this.init();//重新加载数据
    }
  }
}
//方法2  设置路径变化时的处理函数
watch: {
'$route': {
    handler: 'init',
    immediate: true
  }
}
</code></pre>
<h2 id="14路由懒加载">14.路由懒加载</h2>
<p>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</p>
<pre><code class="language-c">// 1、Vue异步组件技术：
    {
        path: '/home',
        name: 'Home',
        component: resolve =&gt; reqire(['path路径'], resolve)
  }

// 2、es6提案的import()
  const Home = () =&gt; import('path路径')

// 3、webpack提供的require.ensure()
    {
        path: '/home',
        name: 'Home',
        component: r =&gt; require.ensure([],() =&gt;  r(require('path路径')), 'demo')
    }
</code></pre>
<h2 id="15自定义路径别名">15.自定义路径别名</h2>
<p>我们也可以在基础配置文件中添加自己的路径别名</p>
<pre><code class="language-c">resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
      'assets': resolve('src/assets')
    }
  }
</code></pre>
<p>然后我们导入组件的时候就可以这样写：</p>
<pre><code class="language-c">// import YourComponent from '/src/assets/YourComponent'
import YourComponent from 'assets/YourComponent'
</code></pre>
<p>这样既解决了路径过长的麻烦，又解决了相对路径的烦恼。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue：内部运行机制]]></title>
        <id>https://dark-yifeng.github.io/post/vue-zhong-de-mo-ban-bian-yi-yuan-li/</id>
        <link href="https://dark-yifeng.github.io/post/vue-zhong-de-mo-ban-bian-yi-yuan-li/">
        </link>
        <updated>2020-05-18T09:37:57.000Z</updated>
        <content type="html"><![CDATA[<p>转载于  https://blog.csdn.net/RedLoVE0908/article/details/99749359</p>
<h3><a name="t1"></a><a name="t1"></a><a id="_2"></a>序</h3>
<p>最近遇到了Vue的瓶颈，不知道怎么样才能得到提升，所以准备从源码和机理入手。</p>
<h3><a name="t2"></a><a name="t2"></a><a id="_5"></a>目录大纲</h3>
<ul>
<li>概述</li>
<li>初始化及挂载</li>
<li>响应式的实现</li>
<li>编译</li>
<li>Virtual DOM和数据更新时的patch()</li>
</ul>
<h3><a name="t3"></a><a name="t3"></a><a id="_13"></a>概述</h3>
<p><img src="https://img-blog.csdnimg.cn/20190819185138874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="Vue.js的内部运行机制"></p>
<ul>
<li><strong>初始化</strong>
<ul>
<li>初始化生命周期、事件、render、state</li>
<li>Object.definePrototy() 响应式的定义</li>
</ul>
</li>
<li><strong>挂载</strong> （运行时 + 编译器）
<ul>
<li>template到render Function的编译</li>
<li>注册watcher</li>
<li>响应式的触发</li>
</ul>
</li>
<li><strong>patch的diff算法更新机制</strong></li>
<li><strong>nextTick的异步更新策略</strong></li>
</ul>
<h3><a name="t4"></a><a name="t4"></a><a id="_26"></a>初始化及挂载</h3>
<p><img src="https://img-blog.csdnimg.cn/2019081918534046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="初始化及挂载"><br>
<strong>Vue</strong>的实现首先是通过<strong>Vue</strong>类里面构造函数中所执行的<strong>init()</strong>。<br>
<strong>_init</strong>的函数里面<strong>主要包括</strong>：</p>
<ol>
<li>主要包括初始化<strong>生命周期</strong>、初始化<strong>事件</strong>、初始化<strong>render</strong>，初始化state(包括<code>props、data，method、computed、watchers</code>)。</li>
<li>执行<code>vm.$mount()</code>挂载组件</li>
</ol>
<p><strong>初始化以及挂载</strong>包括了Vue实例的整个前半的生命周期，在这个过程中，Vue完成了模板到真实DOM的显示，以及data与View的响应式绑定监控。</p>
<h3><a name="t5"></a><a name="t5"></a><a id="_35"></a>响应式的实现</h3>
<h4><a id="ObjectdefinePrototy_37"></a>关于Object.definePrototy()</h4>
<ul>
<li><strong>Object.definePrototy()</strong> :
<ul>
<li><strong>概念</strong>：直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</li>
<li><strong>参数</strong>：<code>obj</code>、<code>prop</code>、<code>descriptor</code></li>
<li><strong>类型</strong>：数据描述符、存取描述符</li>
<li><strong>descriptor</strong> ：
<ul>
<li><code>configureable</code> （数据描述符 &amp; 存取描述符）<br>
当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默	认为 false。</li>
<li><code>emunerable</code>（数据描述符 &amp; 存取描述符）<br>
当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>
<li><code>writable</code> （数据描述符）<br>
当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</li>
<li><code>value</code> （数据描述符）<br>
该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</li>
<li><code>set</code> （存取描述符）<br>
一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认undefined。</li>
<li><code>get</code>（存取描述符）<br>
一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认undefined。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><a id="_56"></a>依赖注入和更新视图</h4>
<p><img src="https://img-blog.csdnimg.cn/20190819190253771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="依赖注入和更新视图"></p>
<ul>
<li><strong>一个Vue类的构造函数中绑定data</strong></li>
<li><strong>为data注册 Observer</strong>
<ul>
<li>对data中的每个key值调用<code>Object.definePrototype</code></li>
<li>在<code>get</code>中执行<code>dep.depend()</code>进行依赖绑定</li>
<li>在<code>set</code>中执行<code>dep.notify()</code>通知观察者进行视图更新</li>
</ul>
</li>
<li><strong>在$mouted执行挂载(运行中+编译器版本)</strong>
<ul>
<li>编译模板将data对象和vue语法声明的模板编译成浏览器可读的html</li>
<li>注册一个观察者<code>Watcher</code>，并将它的getter绑定为<code>vm._update(vm._render())</code></li>
<li>在将<code>Dep.target</code>设置为自生观察者实例，执行getter操作，即为执行了<code>vm._update()</code></li>
<li>在<code>vm._update()</code>中如果需要渲染某个数据就会触发本身的<code>getter</code>，完成依赖收集</li>
</ul>
</li>
<li><strong>当某个值被改变的时候</strong><br>
* 触发<code>set</code>中的<code>dep.notify()</code>通知观察者进行视图更新<br>
* <code>notify</code>调用<code>dep.subs</code>中的每一个<code>watcher</code>的<code>run()</code>进而触发<code>watcher</code>的<code>getter()</code><br>
* 进而触发<code>vm._update(vm._render())</code>进行重新渲染VNode与patch<br>
* 在patch中将新老的VNode进行diff算法分析，找到最小结构，进而更新到真实的DOM上</li>
</ul>
<h5><a id="_73"></a>简单代码示例</h5>
<pre><code class="language-c">		let uid=0
		class Dep {
		    constructor(){
		        this.id = uid++
		        this.subs=[]
		    }
		    addSubs(){
		        this.subs.push(Dep.target)
		    }
		    depend(){
		        if(Dep.target){
		            this.addSubs()
		        }
		    }
		    /*通知所有订阅者*/
		    notify () {    
		        const subs = this.subs.slice()
		        for (let i = 0, l = subs.length; i &lt; l; i++) {
		            subs[i].update()
		        }
		    }
		}
		
		 /*
		    一个解析表达式，进行依赖收集的观察者，同时在表达式数据变更时触发回调函数。它被用于$watch api以及指令
		 */
		class Watcher{
		    constructor(expns){
		        Dep.target=this
		        this.getter = expns
		        this.value = this.get() 
		    }
		    run () {
		        this.get()
		    }
		    update(){
		        this.run()
		    }
		    get(){
		        return this.getter.call(vm)
		    }
		
		}
		
		// 存取描述符（数据描述符）
		function defineReactive(obj,key,val){
		    let dep = new Dep()
		    Object.defineProperty(obj,key,{
		        enumerable:true,//可以修改
		        configurable:true,//可以出现在对象枚举属性
		        get:()=&gt;{
		            //依赖收集
		            if (Dep.target) {
		                /*进行依赖收集*/
		                dep.depend()
		            }
		            return val
		        },
		        set:newVal=&gt;{
		            val=newVal
		            dep.notify()
		        }
		    })
		}
		
		function observe (value){
		    Object.keys(value).forEach(key =&gt; {
		        defineReactive(value,key,value[key])
		    });
		}
		
		
		/*代理*/
		function _proxy (data) {
		    const that = this;
		    Object.keys(data).forEach(key =&gt; {
		        Object.defineProperty(that, key, {
		            configurable: true,
		            enumerable: true,
		            get: function proxyGetter () {
		                return that._data[key];
		            },
		            set: function proxySetter (val) {
		                that._data[key] = val;
		            }
		        })
		    });
		}
		
		let vm 
		class Vue{
		    constructor(options){
		        vm = this
		        //在源码中是通过代理的方式会将_data代理成vm.data
		        this._data=options.data
		        _proxy.call(this, options.data);/*构造函数中*/
		
		        observe(this._data)     
		        // 挂载
		        this._mount()   
		    }
		    _update(){
		        for (const key in this._data) {
		            if (this._data.hasOwnProperty(key)) {
		                console.log('_update渲染更新视图~',this._data[key]);                
		            }
		        }        
		    }
		    _mount(){
		        let updateComponent
		        updateComponent = () =&gt; {
		            vm._update()
		        }   
		       //注册一个观察者     
		        vm._Watcher=new Watcher(updateComponent)
		    }
		}
		
		let app = new Vue({
		    el:'#app',
		    data:{
		        text:'text1',
		        text1:'text2'
		    }
		})
		//修改
		app.text1='0'

</code></pre>
<p>在响应式更新数据的过程中，如果一个数据的值在一段时间内频繁更新了很多次，会依次触发响应式<strong>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch</strong>,所以引入<strong>nextTick</strong>的异步更新策略，实现一个<strong>queue</strong>队列，会在下一个<strong>tick</strong>去执行一次上面的响应式更新操作，大大优化了性能。</p>
<h3><a name="t6"></a><a name="t6"></a><a id="_206"></a>编译</h3>
<p><img src="https://img-blog.csdnimg.cn/20190819190738822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="编译"></p>
<ul>
<li><strong>baseCompile</strong>
<ul>
<li><code>parse</code>——分析</li>
<li><code>optimize</code>——优化</li>
<li><code>generate</code>——生成</li>
</ul>
</li>
<li><strong>createCompileToFunctionFn</strong>
<ul>
<li>将编译结果放入缓存</li>
<li>同时<code>staticRenderFns</code>以及<code>render</code>函数会被转换成Funtion对象</li>
</ul>
</li>
</ul>
<h3><a name="t7"></a><a name="t7"></a><a id="Virtual_DOMpatch_216"></a>Virtual DOM和数据更新时的patch()</h3>
<p><img src="https://img-blog.csdnimg.cn/20190819190954787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="VNode"></p>
<h4><a id="VNode_218"></a>VNode</h4>
<ul>
<li>
<p><strong>产生原因</strong>，对于大应用来说直接操作DOM来修改视图是一个很大的花销。</p>
</li>
<li>
<p><strong>Vue.js</strong>将DOM抽象成一个以JavaScript对象为节点的虚拟DOM树，对这棵抽象树进行节点的增删查改。</p>
</li>
<li>
<p><strong>优点</strong>：</p>
</li>
</ul>
<ol>
<li>不需要操作真实的DOM，只操作JavaScript对象</li>
<li>修改以后经过diff算法得出需修改的最小单位，更新映射到真实的DOM上面去，提高性能。</li>
<li>真实DOM的一层抽象，而不依赖某个平台，可在weex、浏览器平台、甚至是node平台使用<br>
<img src="https://img-blog.csdnimg.cn/20190819191013309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZExvVkUwOTA4,size_16,color_FFFFFF,t_70" alt="patch"></li>
</ol>
<h4><a id="patch_228"></a>数据更新时的patch()</h4>
<ul>
<li>数据发生修改会触发<code>vm._update(vm._render())</code></li>
<li><code>vm._render()</code>返回最新的template的Vnode模板</li>
<li><code>vm._update()</code>中获取到新旧VNode节点进行<code>vm._patch__()</code>函数对比
<ul>
<li>对比过程主要包括对数同层叶子节点的比较</li>
</ul>
</li>
<li>进而对真实DOM进行一系列的<strong>增删查改</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue：模板编译原理]]></title>
        <id>https://dark-yifeng.github.io/post/vuemo-ban-bian-yi-yuan-li/</id>
        <link href="https://dark-yifeng.github.io/post/vuemo-ban-bian-yi-yuan-li/">
        </link>
        <updated>2020-05-18T09:37:57.000Z</updated>
        <content type="html"><![CDATA[<p>先看下模板到真正用户看到的界面过程中经历了什么：</p>
<p>模板———&gt;模板编译——&gt;渲染函数——&gt;vnode——&gt;用于界面</p>
<p>vue.js提供了模板语法，允许我们声明式的描述状态和DOM之间的绑定关系。</p>
<p>将模板编译为渲染函数，就是模板编译要做的事，模板编译可以分为三个阶段：</p>
<p>1.将模板解析为AST（抽象语法树）—— 解析器。<br>
2.遍历AST标记静态节点 —— 优化器。<br>
3.使用AST生成渲染函数 —— 代码生成器）。</p>
<blockquote>
<p>其实 AST 和 Vnode 类似，都是使用JavaScript对象来描述节点。更准确的说，一个用对象来描述的节点树就是 AST。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200316215116732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlpZmVuZzAwMDA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<strong>解析器</strong></p>
<pre><code class="language-c">&lt;div&gt;
  &lt;p&gt;{{name}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>上面一个简单 的模版转换成element AST树形结构后是这样的：</p>
<pre><code class="language-c">{
  tag: &quot;div&quot;
  type: 1,
  staticRoot: false,
  static: false,
  plain: true,
  parent: undefined,
  attrsList: [],
  attrsMap: {},
  children: [
      {
      tag: &quot;p&quot;
      type: 1,
      staticRoot: false,
      static: false,
      plain: true,
      parent: {tag: &quot;div&quot;, ...},
      attrsList: [],
      attrsMap: {},
      children: [{
          type: 2,
          text: &quot;{{name}}&quot;,
          static: false,
          expression: &quot;_s(name)&quot;
      }]
    }
  ]
}
</code></pre>
<p>解析器的原理不是特别难，主要就是两部分内容，一部分是 截取 字符串，一部分是对截取之后的字符串做解析。每截取一段标签的开头就 push 到 stack中，解析到标签的结束就 pop 出来，当所有的字符串都截没了也就解析完了。</p>
<p><strong>优化器</strong><br>
优化器的目的就是找出那些静态节点并打上标记，而静态节点指的是DOM不需要发生变化的节点，也就是里面都是静态标签和静态文本。</p>
<pre><code class="language-c">&lt; p&gt;我是静态节点，我不需要发生变化&lt;/ p&gt;
</code></pre>
<p><strong>标记静态节点有两个好处：</strong></p>
<p>一、每次重新渲染的时候不需要为静态节点创建新节点，也就是静态节点的解析器不需要重新创建<br>
二、在Virtual DOM中patching的过程可以被跳过</p>
<p><strong>优化器的实现原理主要分两步：</strong></p>
<p>一、用递归的方式将静态节点添加static属性，用来标识是不是静态节点<br>
二、标记所有静态根节点(子节点全是静态节点就是静态根节点)</p>
<p>整体逻辑其实就是递归 AST 这颗树，然后将 静态节点和 静态根节点找到并打上标记。</p>
<p><strong>代码生成器</strong><br>
代码生成器的作用是使用element ASTs生成render函数代码字符串。<br>
使用本文开头举的例子中的模版生成后的AST来生成render后是这样的：</p>
<pre><code class="language-c">{
  render: `with(this){return _c('div',[_c('p',[_v(_s(name))])])}`
}
</code></pre>
<p>格式化后是这样的：</p>
<pre><code class="language-c">with(this){
  return _c(
    'div',
    [
      _c(
        'p',
        [
          _v(_s(name))
        ]
      )
    ]
  )
}
</code></pre>
<p>生成后的代码字符串中看到了有几个函数调用_c、_v、_s。<br>
_c对应的是createElement，它的作用是创建一个元素。<br>
1.第一个参数是一个HTML标签名<br>
2.第二个参数是元素上使用的属性所对应的数据对象，可选项<br>
3.第三个参数是children<br>
_v的意思是创建一个文本节点。<br>
_s是返回参数中的字符串。<br>
代码生成器的总体逻辑其实就是使用element ASTs去递归，然后拼出这样的_c('div',[_c('p',[_v(_s(name))])]) 字符串。</p>
<h2 id="原理">原理</h2>
<p>解析器（parser）的原理是一小段一小段的去截取字符串，然后维护一个 stack 用来保存DOM深度，每截取到一段标签的开始就 push 到 stack 中，当所有字符串都截取完之后也就解析出了一个完整的 AST。</p>
<p>优化器（optimizer）的原理是用递归的方式将所有节点打标记，表示是否是一个 静态节点，然后再次递归一遍把 静态根节点 也标记出来。</p>
<p>代码生成器（code generator）的原理也是通过递归去拼一个函数执行代码的字符串，递归的过程根据不同的节点类型调用不同的生成方法，如果发现是一颗元素节点就拼一个 _c(tagName, data, children) 的函数调用字符串，然后 data 和 children 也是使用 AST 中的属性去拼字符串。</p>
<p>如果 children 中还有 children 则递归去拼。</p>
<p>最后拼出一个完整的 render 函数代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue：数据响应式原理]]></title>
        <id>https://dark-yifeng.github.io/post/vue-de-shu-ju-xiang-ying-shi-yuan-li/</id>
        <link href="https://dark-yifeng.github.io/post/vue-de-shu-ju-xiang-ying-shi-yuan-li/">
        </link>
        <updated>2020-05-18T09:23:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是响应式">什么是响应式</h2>
<p>“响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。</p>
<p>举个简单的例子，对于模板：</p>
<pre><code class="language-c">&lt;div id=&quot;root&quot;&gt;{{ name }}&lt;/div&gt;
</code></pre>
<p>创建一个 Vue 组件：</p>
<pre><code class="language-c">var vm = new Vue({
  el: '#root',
  data: {
    name: 'luobo'
  }
})
</code></pre>
<p>代码执行后，页面上对应位置会显示：luobo。</p>
<p>如果想改变显示的名字，只需要执行：</p>
<pre><code class="language-c">vm.name = 'tang'
</code></pre>
<p>这样页面上就会显示修改后的名字了，并不需要去手动修改 DOM 更新数据。</p>
<h2 id="响应式原理">响应式原理</h2>
<p>Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。<img src="https://img-blog.csdnimg.cn/20200304201601974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlpZmVuZzAwMDA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="响应式缺陷">响应式缺陷</h2>
<p><strong>vue不能监听数组的变化</strong></p>
<p>Object.defindProperty虽然能够实现双向绑定了，但是还是有缺点，只能对对象的属性进行数据劫持，所以会深度遍历整个对象，不管层级有多深，只要数组中嵌套有对象，就能监听到对象的数据变化无法监听到数组的变化，Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。</p>
<p><strong>Vue不能检测到对象属性的添加或删除</strong></p>
<p>受现代JS的限制（以及废弃 Object.observe），Vue不能检测到对象属性的添加或删除，由于Vue会在初始化实例时对属性执行 getter/setter转化过程，所以属性必须在data对象上存在才能让Vue转换它，这样才能让它是响应的。</p>
<pre><code class="language-c">var vm = new Vue({
  data:{
  　　a:1
  }
})
// `vm.a` 是响应的
vm.b = 2
// `vm.b` 是非响应的
</code></pre>
<p>Vue不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)，然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。</p>
<pre><code class="language-c">Vue.set(vm.someObject, 'b', 2)
</code></pre>
<p>也可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名。</p>
<pre><code class="language-c">this.$set(this.someObject,'b',2)
</code></pre>
<p>有时想向已有对象上添加一些属性，例如使用Object.assign()或 _.extend()方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性。</p>
<pre><code class="language-c">// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })

</code></pre>
<h2 id="数据双向绑定原理">数据双向绑定原理</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200304235249412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlpZmVuZzAwMDA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="vue30的响应式">Vue3.0的响应式</h2>
<p>Vue.js 3.0的一些新特性，其中一个很重要的改变就是Vue3 将使用 ES6的Proxy 作为其观察者机制，取代之前使用的Object.defineProperty。</p>
<p>Proxy 是ES6中新增的一个特性，可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p><strong>基本用法：</strong></p>
<pre><code class="language-c">//ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。
var proxy = new Proxy(target, handler);
</code></pre>
<p><strong>参数解释</strong><br>
1、target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>
2、handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。</p>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法</p>
<p>Proxy 一共 支持13 种的拦截,相对Object.defineProperty更加丰富。</p>
<p>1.get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。</p>
<p>2.set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。</p>
<p>3.has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</p>
<p>4.deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
<p>5.ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
<p>6.getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
<p>7.defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、<br>
Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
<p>8.preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
<p>9.getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
<p>10.isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
<p>11.setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<p>12.apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、<br>
proxy.call(object, ...args)、proxy.apply(...)。</p>
<p>13.construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。</p>
<h2 id="proxy实现数据劫持">Proxy实现数据劫持</h2>
<pre><code class="language-c">observe(data) {
  const that = this;
  let handler = {
   get(target, property) {
      return target[property];
    },
    set(target, key, value) {
      let res = Reflect.set(target, key, value);
      that.subscribe[key].map(item =&gt; {
        item.update();
      });
      return res;
    }
  }
  this.$data = new Proxy(data, handler);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（十一）：ES7/ES8/ES9/ES10]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptshi-yi-es7es8es9es10/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptshi-yi-es7es8es9es10/">
        </link>
        <updated>2020-05-18T03:35:31.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%BA%8F%E8%A8%80">序言</a></li>
<li><a href="#es7">ES7</a>
<ul>
<li><a href="#1arrayprototypeincludes%E6%96%B9%E6%B3%95">1.Array.prototype.includes()方法</a></li>
<li><a href="#2%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97%E7%AC%A6">2.求幂运算符</a></li>
</ul>
</li>
<li><a href="#es8">ES8</a>
<ul>
<li><a href="#1async-functions">1.Async Functions</a></li>
<li><a href="#2sharedarraybuffer%E5%92%8Catomics">2.SharedArrayBuffer和Atomics</a></li>
<li><a href="#3objectvalues-and-objectentries">3.Object.values and Object.entries</a></li>
<li><a href="#4string-padding">4.String padding</a></li>
<li><a href="#5objectgetownpropertydescriptors">5.Object.getOwnPropertyDescriptors</a></li>
<li><a href="#6%E7%BB%93%E5%B0%BE%E9%80%97%E5%8F%B7">6.结尾逗号</a></li>
</ul>
</li>
<li><a href="#es9">ES9</a>
<ul>
<li><a href="#1%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3">1.异步迭代</a></li>
<li><a href="#2restspread-%E5%B1%9E%E6%80%A7">2.Rest/Spread 属性</a></li>
<li><a href="#3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E7%BB%84-%E7%BC%96%E5%8F%B7%E7%9A%84%E6%8D%95%E8%8E%B7%E7%BB%84">3.正则表达式命名捕获组 编号的捕获组</a></li>
</ul>
</li>
<li><a href="#es10">ES10</a>
<ul>
<li><a href="#1-arrayflat-arrayflatmap">1. Array.flat() &amp; Array.flatMap()</a></li>
<li><a href="#2objectfromentries">2.Object.fromEntries()</a></li>
<li><a href="#3stringtrimstart-stringtrimend">3.String.trimStart() &amp; String.trimEnd()</a></li>
<li><a href="#4symboldescription">4.Symbol.Description</a></li>
<li><a href="#6%E5%8F%AF%E9%80%89%E7%9A%84-catch-%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">6.可选的 Catch 参数变量</a></li>
<li><a href="#6jsonecmascript">6.JSON⊂ECMAScript</a></li>
<li><a href="#7%E6%A0%BC%E5%BC%8F%E8%89%AF%E5%A5%BD%E7%9A%84-jsonstringify">7.格式良好的 JSON.stringify()</a></li>
<li><a href="#8arrayprototypesort">8.Array.prototype.sort()</a></li>
<li><a href="#9%E6%96%B0%E7%89%88-functiontostring">9.新版 Function.toString()</a></li>
<li><a href="#10bigint-%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E6%95%B0">10.BigInt — 任意精度的整数</a></li>
<li><a href="#11%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5">11.动态引入</a></li>
<li><a href="#12%E6%A0%87%E5%87%86-globalthis-%E5%AF%B9%E8%B1%A1">12.标准 globalThis 对象</a></li>
<li><a href="#13es10-class-private-static-public-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0">13.ES10 Class: private, static &amp; public 成员变量，函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="序言">序言</h2>
<p>自从前端开发流行起来，前端的各类技术如雨后春笋般出现，让人应接不暇，几年前还是jq一把梭，现在除了三大主流框架var，何种混合开发也接踵而至，还有可能取代JS的TS出现，我们要跟上时代的步伐，了解最新的技术，走在技术的前沿。</p>
<p>别停留在ES6了，ES10都要出来了。</p>
<h2 id="es7">ES7</h2>
<p>ES7在ES6的基础上主要添加了两项内容：</p>
<p>1.Array.prototype.includes()方法</p>
<p>2.求幂运算符（**）</p>
<h3 id="1arrayprototypeincludes方法">1.Array.prototype.includes()方法</h3>
<p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<pre><code class="language-csharp">var array = [1, 2, 3];

console.log(array.includes(2));
// expected output: true

var pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));
// expected output: true

console.log(pets.includes('at'));
// expected output: false
</code></pre>
<p>Array.prototype.includes()方法接收两个参数：</p>
<p>1.要搜索的值</p>
<p>2.搜索的开始索引。</p>
<p>当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回true，否则返回false。 且看下面示例：</p>
<pre><code class="language-csharp">['a', 'b', 'c', 'd'].includes('b')         // true
['a', 'b', 'c', 'd'].includes('b', 1)      // true
['a', 'b', 'c', 'd'].includes('b', 2)      // false
</code></pre>
<p>乍一看，includes的作用跟数组的indexOf重叠，为什么要特意增加这么一个api呢？主要区别有以下几点：</p>
<p>返回值。看一个函数，先看他们的返回值。indexOf的返回数是值型的，includes的返回值是布尔型，所以在if条件判断的时候includes要简单得多，而indexOf 需要多写一个条件进行判断。</p>
<pre><code class="language-csharp">var ary = [1];
if (ary.indexOf(1) !== -1) {
    console.log(&quot;数组存在1&quot;)
}
if (ary.includes(1)) {
    console.log(&quot;数组存在1&quot;)
}
</code></pre>
<p>NaN的判断。如果数组中有NaN，你又正好需要判断数组是否有存在NaN，这时你使用indexOf是无法判断的，你必须使用includes这个方法。</p>
<pre><code class="language-csharp">var ary1 = [NaN];
console.log(ary1.indexOf(NaN))//-1
console.log(ary1.includes(NaN))//true
</code></pre>
<p>当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会。</p>
<pre><code class="language-csharp">var ary1 = new Array(3);
console.log(ary1.indexOf(undefined));//-1
console.log(ary1.includes(undefined))//true
</code></pre>
<h3 id="2求幂运算符">2.求幂运算符</h3>
<p>加/减法我们通常都是用其中缀形式，直观易懂。在ECMAScript2016中，我们可以使用**来替代Math.pow。</p>
<p>4 ** 3           // 64<br>
效果等同于</p>
<p>Math.pow(4,3)<br>
值得一提的是，作为中缀运算符，**还支持以下操作</p>
<pre><code class="language-csharp">let n = 4;
n **= 3;
// 64
</code></pre>
<h2 id="es8">ES8</h2>
<p>主要新功能：</p>
<p>1.异步函数 Async Functions（Brian Terlson）</p>
<p>2.共享内存和Atomics（Lars T. Hansen）</p>
<p>次要新功能：</p>
<p>1.Object.values / Object.entries（Jordan Harband）</p>
<p>2.String padding（Jordan Harband，Rick Waldron）</p>
<p>3.Object.getOwnPropertyDescriptors() （Jordan Harband，Andrea Giammarchi）</p>
<p>4.函数参数列表和调用中的尾逗号（Jeff Morrison）</p>
<h3 id="1async-functions">1.Async Functions</h3>
<p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱回调地狱，编写更加优雅的代码。</p>
<p>通俗的理解，async关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的await关键字时，要暂时停止运行，带到await标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p>
<p>下面通过拿普通的promise写法来对比，就很好理解了：</p>
<pre><code class="language-csharp">async function asyncFunc() {
    const result = await otherAsyncFunc();
    console.log(result);
}

// Equivalent to:
function asyncFunc() {
    return otherAsyncFunc()
    .then(result =&gt; {
        console.log(result);
    });
}
</code></pre>
<p>按顺序处理多个异步函数的时候优势更为明显：</p>
<pre><code class="language-csharp">async function asyncFunc() {
    const result1 = await otherAsyncFunc1();
    console.log(result1);
    const result2 = await otherAsyncFunc2();
    console.log(result2);
}

// Equivalent to:
function asyncFunc() {
    return otherAsyncFunc1()
    .then(result1 =&gt; {
        console.log(result1);
        return otherAsyncFunc2();
    })
    .then(result2 =&gt; {
        console.log(result2);
    });
}
</code></pre>
<p>并行处理多个异步函数：</p>
<pre><code class="language-csharp">async function asyncFunc() {
    const [result1, result2] = await Promise.all([
        otherAsyncFunc1(),
        otherAsyncFunc2(),
    ]);
    console.log(result1, result2);
}

// Equivalent to:
function asyncFunc() {
    return Promise.all([
        otherAsyncFunc1(),
        otherAsyncFunc2(),
    ])
    .then([result1, result2] =&gt; {
        console.log(result1, result2);
    });
}
</code></pre>
<p>处理错误：</p>
<pre><code class="language-csharp">async function asyncFunc() {
    try {
        await otherAsyncFunc();
    } catch (err) {
        console.error(err);
    }
}

// Equivalent to:
function asyncFunc() {
    return otherAsyncFunc()
    .catch(err =&gt; {
        console.error(err);
    });
}
</code></pre>
<h3 id="2sharedarraybuffer和atomics">2.SharedArrayBuffer和Atomics</h3>
<p>ECMAScript 2017 特性 SharedArrayBuffer 和 atomics”，由Lars T. Hansen设计。它引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。</p>
<p>在我们开始之前，让我们澄清两个相似但截然不同的术语：并行(Parallelism) 和 并发(Concurrency) 。他们存在许多定义，我使用的定义如下</p>
<p>并行(Parallelism) (parallel 并行 vs. serial 串行)：同时执行多个任务；</p>
<p>并发(Concurrency) (concurrent 并发 vs. sequential 连续)：在重叠的时间段内（而不是一个接一个）执行几个任务。</p>
<p><strong>JS并行的历史</strong></p>
<p>JavaScript 在单线程中执行。某些任务可以异步执行：浏览器通常会在单线程中运行这些任务，然后通过回调将结果重新加入到单线程中。</p>
<p>Web workers 将任务并行引入了 JavaScript ：这些是相对重量级的进程。每个 workers 都有自己的全局环境。默认情况下，不共享任何内容。 workers 之间的通信（或在 workers 和主线程之间的通信）发展：</p>
<p>起初，你只能发送和接收字符串。</p>
<p>然后，引入结构化克隆：可以发送和接收数据副本。结构化克隆适用于大多数数据（JSON 数据，TypedArray，正则表达式，Blob对象，ImageData对象等）。它甚至可以正确处理对象之间的循环引用。但是，不能克隆 error 对象，function 对象和 DOM 节点。</p>
<p>可在 workers 之间的转移数据:当接收方获得数据时，发送方失去访问权限。</p>
<p>通过 WebGL 使用 GPU 计算(它倾向于数据并行处理)</p>
<p><strong>共享数组缓冲区（Shared Array Buffers）</strong></p>
<p>共享阵列缓冲区是更高并发抽象的基本构建块。它们允许您在多个 workers 和主线程之间共享 SharedArrayBuffer 对象的字节(该缓冲区是共享的，用于访问字节，将其封装在一个 TypedArray 中)这种共享有两个好处：</p>
<p>你可以更快地在 workers 之间共享数据。<br>
workers 之间的协调变得更简单和更快（与 postMessage() 相比）。</p>
<pre><code class="language-csharp">// main.js
const worker = new Worker('worker.js');

// 要分享的buffer
const sharedBuffer = new SharedArrayBuffer( // (A)
    10 * Int32Array.BYTES_PER_ELEMENT); // 10 elements

// 使用Worker共用sharedBuffer
worker.postMessage({sharedBuffer}); // clone

// 仅限本地使用
const sharedArray = new Int32Array(sharedBuffer); // (B)
</code></pre>
<p>创建一个共享数组缓冲区（Shared Array Buffers）的方法与创建普通的数组缓冲区(Array Buffer)类似：通过调用构造函数，并以字节的形式指定缓冲区的大小(行A)。你与 workers 共享的是 缓冲区（buffer） 。对于你自己的本地使用，你通常将共享数组缓冲区封装在 TypedArray 中(行B)。</p>
<p>workers的实现如下所列。</p>
<pre><code class="language-csharp">// worker.js
self.addEventListener('message', function (event) {
    const {sharedBuffer} = event.data;
    const sharedArray = new Int32Array(sharedBuffer); // (A)
    // ···
});
</code></pre>
<p><strong>sharedArrayBuffer 的 API</strong></p>
<p>构造函数：</p>
<p>new SharedArrayBuffer(length)</p>
<p>创建一个 length 字节的 buffer(缓冲区)。</p>
<p>静态属性：</p>
<p>get SharedArrayBuffer[Symbol.species]</p>
<p>默认情况下返回 this。 覆盖以控制 slice() 的返回。</p>
<p>实例属性：</p>
<p>get SharedArrayBuffer.prototype.byteLength()</p>
<p>返回 buffer(缓冲区) 的字节长度。</p>
<p>SharedArrayBuffer.prototype.slice(start, end)</p>
<p>创建一个新的 this.constructor[Symbol.species] 实例，并用字节填充从（包括）开始到（不包括）结束的索引。</p>
<p>Atomics: 安全访问共享数据<br>
举一个例子</p>
<pre><code class="language-csharp">// main.js
sharedArray[1] = 11;
sharedArray[2] = 22;
</code></pre>
<p>在单线程中，您可以重新排列这些写入操作，因为在中间没有读到任何内容。 对于多线程，当你期望以特定顺序执行写入操作时，就会遇到麻烦：</p>
<pre><code class="language-csharp">// worker.js
while (sharedArray[2] !== 22) ;
console.log(sharedArray[1]); // 0 or 11
Atomics 方法可以用来与其他 workers 进行同步。例如，以下两个操作可以让你读取和写入数据，并且不会被编译器重新排列：

Atomics.load(ta : TypedArray, index)

Atomics.store(ta : TypedArray, index, value : T)
</code></pre>
<p>这个想法是使用常规操作读取和写入大多数数据，而 Atomics 操作（load ，store 和其他操作）可确保读取和写入安全。通常，您将使用自定义同步机制，例如锁，其实现基于Atomics。</p>
<p>这是一个非常简单的例子，它总是有效的：</p>
<pre><code class="language-csharp">// main.js
console.log('notifying...');
Atomics.store(sharedArray, 0, 123);

// worker.js
while (Atomics.load(sharedArray, 0) !== 123) ;
console.log('notified');
</code></pre>
<p><strong>Atomics 的 API</strong></p>
<p>Atomic 函数的主要操作数必须是 Int8Array ，Uint8Array ，Int16Array ，Uint16Array ，Int32Array 或 Uint32Array 的一个实例。它必须包裹一个 SharedArrayBuffer 。</p>
<p>所有函数都以 atomically 方式进行操作。存储操作的顺序是固定的并且不能由编译器或 CPU 重新排序。</p>
<p>加载和存储</p>
<p>Atomics.load(ta : TypedArray<T>, index) : T</p>
<p>读取和返回 ta[index] 上的元素，返回数组指定位置上的值。</p>
<p>Atomics.store(ta : TypedArray<T>, index, value : T) : T</p>
<p>在 ta[index] 上写入 value，并且返回 value。</p>
<p>Atomics.exchange(ta : TypedArray<T>, index, value : T) : T</p>
<p>将 ta[index] 上的元素设置为 value ，并且返回索引 index 原先的值。</p>
<p>Atomics.compareExchange(ta : TypedArray<T>, index, expectedValue, replacementValue) : T</p>
<p>如果 ta[index] 上的当前元素为 expectedValue , 那么使用 replacementValue 替换。并且返回索引 index 原先（或者未改变）的值。</p>
<p>简单修改 TypeArray 元素</p>
<p>以下每个函数都会在给定索引处更改 TypeArray 元素：它将一个操作符应用于元素和参数，并将结果写回元素。它返回元素的原始值。</p>
<p>Atomics.add(ta : TypedArray<T>, index, value) : T</p>
<p>执行 ta[index] += value 并返回 ta[index] 的原始值。</p>
<p>Atomics.sub(ta : TypedArray<T>, index, value) : T</p>
<p>执行 ta[index] -= value 并返回 ta[index] 的原始值。</p>
<p>Atomics.and(ta : TypedArray<T>, index, value) : T</p>
<p>执行 ta[index] &amp;= value 并返回 ta[index] 的原始值。</p>
<p>Atomics.or(ta : TypedArray<T>, index, value) : T</p>
<p>执行 ta[index] |= value 并返回 ta[index] 的原始值。</p>
<p>Atomics.xor(ta : TypedArray<T>, index, value) : T</p>
<p>执行 ta[index] ^= value 并返回 ta[index] 的原始值。</p>
<p>等待和唤醒</p>
<p>Atomics.wait(ta: Int32Array, index, value, timeout=Number.POSITIVE_INFINITY) : ('not-equal' | 'ok' | 'timed-out')</p>
<p>如果 ta[index] 的当前值不是 value ，则返回 'not-equal'。否则继续等待，直到我们通过 Atomics.wake() 唤醒或直到等待超时。 在前一种情况下，返回 'ok'。在后一种情况下，返回'timed-out'。timeout 以毫秒为单位。记住此函数执行的操作：“如果 ta[index] 为 value，那么继续等待” 。</p>
<p>Atomics.wake(ta : Int32Array, index, count)</p>
<p>唤醒等待在 ta[index] 上的 count workers。</p>
<h3 id="3objectvalues-and-objectentries">3.Object.values and Object.entries</h3>
<p>Object.values() 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。</p>
<p>obj参数是需要待操作的对象。可以是一个对象，或者一个数组（是一个带有数字下标的对象，[10,20,30] -&gt; {0: 10,1: 20,2: 30})。</p>
<pre><code class="language-csharp">const obj = { x: 'xxx', y: 1 };
Object.values(obj); // ['xxx', 1]

const obj = ['e', 's', '8']; // 相当于 { 0: 'e', 1: 's', 2: '8' };
Object.values(obj); // ['e', 's', '8']

// 当我们使用数字键值时，返回的是数字排序
// 根据键值排序
const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };
Object.values(obj); // ['yyy', 'zzz', 'xxx']

Object.values('es8'); // ['e', 's', '8']
</code></pre>
<p>Object.entries 方法返回一个给定对象自身可遍历属性 [key, value] 的数组， 排序规则和 Object.values 一样。这个方法的声明比较琐碎:</p>
<pre><code class="language-csharp">const obj = { x: 'xxx', y: 1 };
Object.entries(obj); // [['x', 'xxx'], ['y', 1]]

const obj = ['e', 's', '8'];
Object.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]

const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };
Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]

Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']]
</code></pre>
<h3 id="4string-padding">4.String padding</h3>
<p>为 String 对象增加了 2 个函数：padStart 和 padEnd。</p>
<p>像它们名字那样，这几个函数的主要目的就是填补字符串的首部和尾部，为了使得到的结果字符串的长度能达到给定的长度。你可以通过特定的字符，或者字符串，或者默认的空格填充它。下面是函数的声明：</p>
<pre><code class="language-csharp">str.padStart(targetLength [, padString])
str.padEnd(targetLength [, padString])
</code></pre>
<p>这些函数的第一个参数是 targetLength（目标长度），这个是结果字符串的长度。第二个参数是可选的 padString（填充字符），一个用于填充到源字符串的字符串。默认值是空格。</p>
<pre><code class="language-csharp">'es8'.padStart(2);          // 'es8'
'es8'.padStart(5);          // '  es8'
'es8'.padStart(6, 'woof');  // 'wooes8'
'es8'.padStart(14, 'wow');  // 'wowwowwowwoes8'
'es8'.padStart(7, '0');     // '0000es8'

'es8'.padEnd(2);            // 'es8'
'es8'.padEnd(5);            // 'es8  '
'es8'.padEnd(6, 'woof');    // 'es8woo'
'es8'.padEnd(14, 'wow');    // 'es8wowwowwowwo'
'es8'.padEnd(7, '6');       // 'es86666'
</code></pre>
<h3 id="5objectgetownpropertydescriptors">5.Object.getOwnPropertyDescriptors</h3>
<p>getOwnPropertyDescriptors 方法返回指定对象所有自身属性的描述对象。属性描述对象是直接在对象上定义的，而不是继承于对象的原型。ES2017加入这个函数的主要动机在于方便将一个对象深度拷贝给另一个对象，同时可以将getter/setter拷贝。声明如下：</p>
<pre><code class="language-csharp">Object.getOwnPropertyDescriptors(obj)
</code></pre>
<p>obj 是待操作对象。返回的描述对象键值有：configurable, enumerable, writable, get, set and value。</p>
<pre><code class="language-csharp">const obj = { 
  get es7() { return 777; },
  get es8() { return 888; }
};
Object.getOwnPropertyDescriptor(obj);
// {
//   es7: {
//     configurable: true,
//     enumerable: true,
//     get: function es7(){}, //the getter function
//     set: undefined
//   },
//   es8: {
//     configurable: true,
//     enumerable: true,
//     get: function es8(){}, //the getter function
//     set: undefined
//   }
// }
</code></pre>
<h3 id="6结尾逗号">6.结尾逗号</h3>
<p>结尾逗号用代码展示非常明了：</p>
<pre><code class="language-csharp">// 参数定义时
function foo(
    param1,
    param2,
) {}

// 函数调用时
foo(
    'abc',
    'def',
);

// 对象中
let obj = {
    first: 'Jane',
    last: 'Doe',
};

// 数组中
let arr = [
    'red',
    'green',
    'blue',
];
</code></pre>
<p>这个改动有什么好处呢？</p>
<p>首先，重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</p>
<p>其次，它可以帮助版本控制系统跟踪实际发生的变化。例如，从：</p>
<pre><code class="language-csharp">[
    'foo'
]
修改为

[
    'foo',
    'bar'
]
</code></pre>
<p>导致线条'foo'和线条'bar'被标记为已更改，即使唯一真正的变化是后一条线被添加。</p>
<p>结尾逗号用代码展示非常明了：</p>
<p>// 参数定义时<br>
function foo(<br>
param1,<br>
param2,<br>
) {}</p>
<p>// 函数调用时<br>
foo(<br>
'abc',<br>
'def',<br>
);</p>
<p>// 对象中<br>
let obj = {<br>
first: 'Jane',<br>
last: 'Doe',<br>
};</p>
<p>// 数组中<br>
let arr = [<br>
'red',<br>
'green',<br>
'blue',<br>
];<br>
这个改动有什么好处呢？</p>
<p>首先，重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</p>
<p>其次，它可以帮助版本控制系统跟踪实际发生的变化。例如，从：</p>
<p>[<br>
'foo'<br>
]<br>
修改为</p>
<p>[<br>
'foo',<br>
'bar'<br>
]<br>
导致线条'foo'和线条'bar'被标记为已更改，即使唯一真正的变化是后一条线被添加。</p>
<h2 id="es9">ES9</h2>
<p>ES9的新特性索引如下：</p>
<p>主要新功能：</p>
<p>1.异步迭代（Domenic Denicola，Kevin Smith）</p>
<p>2.Rest/Spread 属性（SebastianMarkbåge）</p>
<p>新的正则表达式功能：</p>
<p>1.RegExp named capture groups（Gorkem Yakin，Daniel Ehrenberg）</p>
<p>2.RegExp Unicode Property Escapes（Mathias Bynens）</p>
<p>3.RegExp Lookbehind Assertions（Gorkem Yakin，NozomuKatō，Daniel Ehrenberg）</p>
<p>4.s (dotAll) flag for regular expressions（Mathias Bynens）</p>
<p>其他新功能：</p>
<p>1.Promise.prototype.finally() （Jordan Harband）</p>
<p>2.模板字符串修改（Tim Disney）</p>
<h3 id="1异步迭代">1.异步迭代</h3>
<p>首先来回顾一下同步迭代器：<br>
ES6引入了同步迭代器，其工作原理如下：</p>
<p>Iterable：一个对象，表示可以通过Symbol.iterator方法进行迭代。</p>
<p>Iterator：通过调用iterable [Symbol.iterator] ()返回的对象。它将每个迭代元素包装在一个对象中，并通过其next()方法一次返回一个。</p>
<p>IteratorResult：返回的对象next()。属性value包含一个迭代的元素，属性done是true 后最后一个元素。</p>
<p>示例：</p>
<pre><code class="language-csharp">const iterable = ['a', 'b'];
const iterator = iterable[Symbol.iterator]();
iterator.next()
// { value: 'a', done: false }
iterator.next()
// { value: 'b', done: false }
iterator.next()
// { value: undefined, done: true }
</code></pre>
<p><strong>异步迭代器</strong></p>
<p>先前的迭代方式是同步的，并不适用于异步数据源。例如，在以下代码中，readLinesFromFile()无法通过同步迭代传递其异步数据：</p>
<p>for (const line of readLinesFromFile(fileName)) {<br>
console.log(line);<br>
}<br>
异步迭代器和常规迭代器的工作方式非常相似，但是异步迭代器涉及promise:</p>
<pre><code class="language-csharp">async function example() {
  // 普通迭代器:
  const iterator = createNumberIterator();
  iterator.next(); // Object {value: 1, done: false}
  iterator.next(); // Object {value: 2, done: false}
  iterator.next(); // Object {value: 3, done: false}
  iterator.next(); // Object {value: undefined, done: true}

  // 异步迭代器:
  const asyncIterator = createAsyncNumberIterator();
  const p = asyncIterator.next(); // Promise
  await p;// Object {value: 1, done: false}
  await asyncIterator.next(); // Object {value: 2, done: false}
  await asyncIterator.next(); // Object {value: 3, done: false}
  await asyncIterator.next(); // Object {value: undefined, done: true}
}
异步迭代器对象的next()方法返回了一个Promise，解析后的值跟普通的迭代器类似。
用法：iterator.next().then(({ value, done })=&gt; {//{value: ‘some val’, done: false}}

const promises = [
    new Promise(resolve =&gt; resolve(1)),
    new Promise(resolve =&gt; resolve(2)),
    new Promise(resolve =&gt; resolve(3)),
];

async function test() {
    for await (const p of promises) {
        console.log(p);
    }
}
test(); //1 ,2 3
</code></pre>
<h3 id="2restspread-属性">2.Rest/Spread 属性</h3>
<p>这个就是我们通常所说的rest参数和扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组：</p>
<pre><code class="language-csharp">restParam(1, 2, 3, 4, 5);

function restParam(p1, p2, ...p3) {
  // p1 = 1
  // p2 = 2
  // p3 = [3, 4, 5]
}

const values = [99, 100, -1, 48, 16];
console.log( Math.max(...values) ); // 100
</code></pre>
<p>在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p>
<pre><code class="language-csharp">const obj = {
  a: 1,
  b: 2,
  c: 3
}
const { a, ...param } = obj;
  console.log(a)     //1
  console.log(param) //{b: 2, c: 3}

function foo({a, ...param}) {
  console.log(a);    //1
  console.log(param) //{b: 2, c: 3}
}
</code></pre>
<h3 id="3正则表达式命名捕获组-编号的捕获组">3.正则表达式命名捕获组 编号的捕获组</h3>
<pre><code class="language-csharp">//正则表达式命名捕获组
const RE_DATE = /([0-9]{4})-([0-9]{2})-([0-9]{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
</code></pre>
<p>通过数字引用捕获组有几个缺点：</p>
<p>1.找到捕获组的数量是一件麻烦事：必须使用括号。</p>
<p>2.如果要了解组的用途，则需要查看正则表达式。</p>
<p>3.如果更改捕获组的顺序，则还必须更改匹配代码。</p>
<p><strong>命名的捕获组</strong></p>
<p>ES9中可以通过名称来识别捕获组：(?<year>[0-9]{4})</p>
<p>在这里，我们用名称标记了前一个捕获组year。该名称必须是合法的JavaScript标识符（认为变量名称或属性名称）。匹配后，您可以通过访问捕获的字符串matchObj.groups.year来访问。</p>
<p>让我们重写前面的代码：</p>
<pre><code class="language-csharp">const RE_DATE = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31

// 使用解构语法更为简便
const {groups: {day, year}} = RE_DATE.exec('1999-12-31');
console.log(year); // 1999
console.log(day); // 31
</code></pre>
<p>可以发现，命名捕获组有以下优点：</p>
<p>找到捕获组的“ID”更容易。</p>
<p>匹配代码变为自描述性的，因为捕获组的ID描述了正在捕获的内容。</p>
<p>如果更改捕获组的顺序，则无需更改匹配代码。</p>
<p>捕获组的名称也使正则表达式更容易理解，因为您可以直接看到每个组的用途。</p>
<p><strong>正则表达式 Unicode 转义</strong></p>
<p>该特性允许您使用\p{}通过提及大括号内的Unicode字符属性来匹配字符,在正则表达式中使用标记 u (unicode) 设置。</p>
<pre><code class="language-csharp">/^\p{White_Space}+$/u.test('\t \n\r')
// true
/^\p{Script=Greek}+$/u.test('μετά')
// true
</code></pre>
<h2 id="es10">ES10</h2>
<p><strong>ES10还在草案，所以这里只有介绍。</strong></p>
<p>ES2019中的JavaScript新功能包括：</p>
<p>1.Array#{flat,flatMap}</p>
<p>2.Object.fromEntries</p>
<p>3.String#{trimStart,trimEnd}</p>
<p>4.Symbol#description</p>
<p>5.try { } catch {} // 可选的错误参数绑定</p>
<p>6.JSON ⊂ ECMAScript</p>
<p>7.格式良好的 JSON.stringify</p>
<p>8.稳定的排序 Array#sort</p>
<p>9.新版 Function#toString</p>
<p>10.新增 BigInt 原始类型 (stage 3).</p>
<p>11.动态引入模块(stage 3).</p>
<p>12.标准的 globalThis 对象 (stage 3).</p>
<p>13.ES10 Class: private, static &amp; public (stage 3).</p>
<h3 id="1-arrayflat-arrayflatmap">1. Array.flat() &amp; Array.flatMap()</h3>
<p>两个新的数组方法：</p>
<p>Array.flat() 方法创建一个新数组，所有子数组元素都以递归方式合并到该数组中，直至达到指定深度。</p>
<p>Array.flatMap() 方法首先使用map函数转换每个元素，然后将结果展平为新数组。它与map()后再调用深度为1的flat() 效果相同，但是flatMap()将两者合并为一种方法，效率更高。</p>
<h3 id="2objectfromentries">2.Object.fromEntries()</h3>
<p>把键值对数组为元素的二维数组转换为一个对象。</p>
<h3 id="3stringtrimstart-stringtrimend">3.String.trimStart() &amp; String.trimEnd()</h3>
<p>有两种新的String方法可从字符串中删除空格：</p>
<p>trimStart() 方法从字符串的开头删除空格。<br>
trimEnd() 方法从字符串末尾删除空格。</p>
<h3 id="4symboldescription">4.Symbol.Description</h3>
<p>当创建符号时，可以提供一个字符串作为描述。在ES10中，有一个获取描述的访问器。</p>
<h3 id="6可选的-catch-参数变量">6.可选的 Catch 参数变量</h3>
<p>过去，try / catch语句中的catch子句需要一个变量。现在，它允许开发人员使用try / catch而不创建未使用的error变量绑定。</p>
<h3 id="6jsonecmascript">6.JSON⊂ECMAScript</h3>
<p>在ES10之前的版本中，不接受非转义的行分隔符U+2028和段落分隔符U+2029。</p>
<p>U+2028是段落分隔符。<br>
U+2029是行分隔符。</p>
<h3 id="7格式良好的-jsonstringify">7.格式良好的 JSON.stringify()</h3>
<p>JSON.stringify() 可能返回U+D800和U+DFFF之间的字符，来作为没有等效UTF-8字符的值。但是，JSON格式需要UTF-8编码。解决方案是，将未配对的替代代码点表示为JSON转义序列，而不是将其作为单个UTF-16代码单元返回。</p>
<h3 id="8arrayprototypesort">8.Array.prototype.sort()</h3>
<p>V8的先前实现，对包含10个以上项的数组使用了不稳定的快速排序算法。</p>
<p>一种稳定的排序算法是，当两个具有相同键的对象在排序输出中出现的顺序，与未排序输入中出现的顺序相同。</p>
<h3 id="9新版-functiontostring">9.新版 Function.toString()</h3>
<p>toString() 方法返回一个表示函数源代码的字符串。在ES6中，当在函数上调用toString时，它将根据ECMAScript引擎返回该函数的字符串表示形式。如果可能，它将返回源代码，否则-一个标准化的占位符。</p>
<h3 id="10bigint-任意精度的整数">10.BigInt — 任意精度的整数</h3>
<p>BigInt是第7个原始类型，它是一个任意精度的整数。而不仅仅是在9007199254740992处的最大值。</p>
<h3 id="11动态引入">11.动态引入</h3>
<p>动态import()返回所请求模块的Promise。因此，可以使用async/await 将导入的模块分配给变量。</p>
<h3 id="12标准-globalthis-对象">12.标准 globalThis 对象</h3>
<p>全局 this 在ES10之前尚未标准化。在生产代码中，您可以通过编写下边代码来“标准化”它：</p>
<h3 id="13es10-class-private-static-public-成员变量函数">13.ES10 Class: private, static &amp; public 成员变量，函数</h3>
<p>现在，新的语法字符＃（哈希标签）用于直接在类中定义变量，函数，getter和setter，以及构造函数和类方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（十）：this/call/apply/bind]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptshi-thiscallapplybind/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptshi-thiscallapplybind/">
        </link>
        <updated>2020-05-18T03:34:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-this">一、this</a>
<ul>
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AFthis">1.什么是this</a></li>
<li><a href="#2this-%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88">2.this 代表什么</a></li>
<li><a href="#3%E7%BB%91%E5%AE%9A-this-%E7%9A%84%E6%96%B9%E6%B3%95">3.绑定 this 的方法</a></li>
<li><a href="#4this%E7%9A%84%E6%8C%87%E5%90%91">4.this的指向</a></li>
<li><a href="#5%E6%94%B9%E5%8F%98%E6%8C%87%E5%90%91">5.改变指向</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-functionprototypebind">二、Function.prototype.bind()</a></li>
<li><a href="#%E4%B8%89-callapply">三、call/apply</a>
<ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E8%AF%AD%E6%B3%95">2.语法</a></li>
<li><a href="#3%E5%BC%82%E5%90%8C">3.异同</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-this">一、this</h2>
<h3 id="1什么是this">1.什么是this</h3>
<p>this 关键字在大部分语言中都是一个重要的存在，JS中自然不例外，其表达的意义丰富多样甚至有些复杂，深刻理解this是学习JS、面向对象编程非常重要的一环。</p>
<h3 id="2this-代表什么">2.this 代表什么</h3>
<p>this代表函数（方法）执行的上下文环境（上下文，类似与你要了解一篇文章，了解文章的上下文你才能清晰的了解各种关系）。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<p>1.在方法中，this 表示该方法所属的对象。</p>
<p>2.如果单独使用，this 表示全局对象。</p>
<p>3.在函数中，this 表示全局对象。</p>
<p>4.在函数中，在严格模式下，this 是未定义的(undefined)。</p>
<p>5.在事件中，this 表示接收事件的元素。</p>
<p>6.类似 call() 和 apply() 方法可以将 this 引用到任何对象。</p>
<h3 id="3绑定-this-的方法">3.绑定 this 的方法</h3>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p>
<h3 id="4this的指向">4.this的指向</h3>
<p><strong>1.在一般函数方法中使用 this 指代全局对象</strong></p>
<pre><code class="language-csharp">function test(){
　　　　this.x = 1;  //这里this就是window
　　　　console.log(this.x);
　　}
　　test(); // 1
</code></pre>
<p>JS规定，函数中的this，在函数被调用时确定，它指函数当前运行的环境。</p>
<p><strong>2.作为对象方法调用，this 指代上级对象</strong></p>
<pre><code class="language-csharp">var x =3;
function test(){
　　alert(this.x);
}
var o = {
  x:1,
  m:test 
};
o.m(); // 1
</code></pre>
<p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>
<p><strong>3.作为构造函数调用，this 指代new 出的对象</strong></p>
<pre><code class="language-csharp">function test(){
　　　　console.log(this);
　　}
　　var o = new test();
       test();
//可以看出o代表的不是全局对象
</code></pre>
<p>new关键词的作用是调用某个函数并拿到其中的返回值，只是调用过程稍特殊。在上面的代码实例中。test函数被new关键词调用时，内部依次执行了以下步骤:</p>
<p>（1）创建一个空对象。</p>
<p>（2）将这个空对象的原型，指向这个构造函数的prototype。</p>
<p>（3）将空对象的值赋给函数内部的this（this就是个空对象了）。</p>
<p>（4）执行函数体代码，为this这个对象绑定键值对。</p>
<p>（5）返回this，将其作为new关键词调用oop函数的返回值。</p>
<p>所以构造函数中的this，依旧是在构造函数被new关键词调用时确定其指向，指向的是当前被实例化的那个对象。</p>
<p><strong>4.箭头函数中的this</strong><br>
箭头函数是ES6的新特性，最重要的特点是它会捕获其所在上下文的this作为自己的this，或者说，箭头函数本身并没有this，它会沿用外部环境的this。也就是说，箭头函数内部与其外部的this是保持一致的。</p>
<pre><code class="language-csharp">this.a=20
var test={
    a:40，
    init:()=&gt;{
        console.log(this.a)
        function go(){
            this.a=60
            console.log(this.a)
        }
        go.prototype.a=50
        return go
    }   
}

var p=test.init()
p()
new (test.init())()
//输出 20 60 60 60
</code></pre>
<h3 id="5改变指向">5.改变指向</h3>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p>
<p>bind方法和apply、call稍有不同，bind方法返回一个新函数，以后调用了才会执行，但apply、call会立即执行。</p>
<h2 id="二-functionprototypebind">二、Function.prototype.bind()</h2>
<p>bind()方法主要就是将函数绑定到某个对象，bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()中的第一个参数的值，例如：f.bind(obj)，实际上可以理解为obj.f()，这时f函数体内的this自然指向的是obj；</p>
<p><strong>示例：</strong></p>
<pre><code class="language-csharp">function f(y, z){
    return this.x + y + z;
}
var m = f.bind({x : 1}, 2);
console.log(m(3));
//6
</code></pre>
<p>这里bind方法会把它的第一个实参绑定给f函数体内的this，所以这里的this即指向{x : 1}对象，从第二个参数起，会依次传递给原始函数，这里的第二个参数2，即是f函数的y参数，最后调用m(3)的时候，这里的3便是最后一个参数z了，所以执行结果为1 + 2 + 3 = 6分步处理参数的过程其实是一个典型的函数柯里化的过程（Curry）。</p>
<h2 id="三-callapply">三、call/apply</h2>
<h3 id="1定义">1.定义</h3>
<p>每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</p>
<p>call和apply可以用来重新定义函数的执行环境，也就是this的指向；call和apply都是为了改变某个函数运行时的context，即上下文而存在的，换句话说，就是为了改变函数体内部this的指向。</p>
<h3 id="2语法">2.语法</h3>
<p><strong>call()</strong></p>
<p>调用一个对象的方法，用另一个对象替换当前对象，可以继承另外一个对象的属性，它的语法是：</p>
<pre><code class="language-csharp">Function.call(obj[, param1[, param2[, [,...paramN]]]]);
</code></pre>
<p>obj：这个对象将代替Function类里this对象<br>
params：一串参数列表</p>
<p>说明：call方法可以用来代替另一个对象调用一个方法，call方法可以将一个函数的对象上下文从初始的上下文改变为obj指定的新对象，如果没有提供obj参数，那么Global对象被用于obj。</p>
<p><strong>apply()</strong></p>
<p>和call()方法一样，只是参数列表不同，语法：</p>
<p><strong>Function.apply(obj[, argArray]);</strong></p>
<p>obj：这个对象将代替Function类里this对象<br>
argArray：这个是数组，它将作为参数传给Function</p>
<p>说明：如果argArray不是一个有效数组或不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和obj任何一个参数，那么Global对象将用作obj。</p>
<h3 id="3异同">3.异同</h3>
<p><strong>相同点</strong></p>
<p>call()和apply()方法的相同点就是这两个方法的作用是一样的。都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。</p>
<p>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向，看个例子：</p>
<pre><code class="language-csharp">function add(a, b) {
    return a + b;
}

function sub(a, b) {
    return a - b;
}

console.log(add.call(sub, 2, 1));//3
</code></pre>
<p>为什么add.call(sub, 2, 1)的执行结果是3呢，因为call()方法改变了this的指向，使得sub可以调用add的方法，也就是用sub去执行add中的内容，再来看一个例子：</p>
<pre><code class="language-csharp">function People(name, age) {
    this.name = name;
    this.age = age;
}

function Student(name, age, grade) {
    People.call(this, name, age);
    this.grade = grade;
}

var student = new Student('小明', 21, '大三');
console.log(student.name + student.age + student.grade);//小明21大三
</code></pre>
<p>在这个例子中，我们并没有给Student的name和age赋值，但是存在这两个属性的值，这还是要归功于call()方法，它可以改变this的指向。<br>
在这个例子里，People.call(this, name, age);中的this代表的是Student，这也就是之前说的，使得Student可以调用People中的方法，因为People中有this.name = name;等语句，这样就将name和age属性创建到了Student中。</p>
<p>总结一句话就是call()可以让括号里的对象来继承括号外函数的属性。</p>
<p>至于apply()方法作用也和call()方法一样，可以这么写：</p>
<pre><code class="language-csharp">People.apply(this, [name, age]);
</code></pre>
<p>或者这么写：</p>
<pre><code class="language-csharp">People.apply(this, arguments);
</code></pre>
<p>在这里arguments和[name, age]是等价的。</p>
<p><strong>不同点</strong></p>
<p>从定义中也可以看出来，call()和apply()的不同点就是接收参数的方式不同。</p>
<p>1.apply()方法接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。<br>
2.call()方法不一定接受两个参数，第一个参数也是函数运行的作用域（this），但是传递给函数的参数必须列举出来。</p>
<p>在给对象参数的情况下,如果参数的形式是数组的时候,比如之前apply()方法示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的)就可以采用apply()方法。</p>
<p>但是如果Person的参数列表是这样的(age,name)，而Student的参数列表是(name,age,grade)，这样就可以用call()方法来实现了,也就是直接指定参数列表对应值的位置Person.call(this,age,name)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（九）：async/await]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptjiu-asyncawait/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptjiu-asyncawait/">
        </link>
        <updated>2020-05-18T03:33:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1-asyncawait是什么">1. async/await是什么？</h2>
<p>async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数。</p>
<p>await 也是一个修饰符，await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值。</p>
<p><strong>那么async/await到底是干嘛的呢？</strong></p>
<p>1.async/await 是一种编写异步代码的新方法。之前异步代码的方案是回调和 promise。<br>
2.async/await 是建立在 promise 的基础上。（如果对Promise不熟悉，我已经着手在写Promise的文章了）<br>
3.async/await 像 promise 一样，也是非阻塞的。<br>
4.async/await 让异步代码看起来、表现起来更像同步代码。这正是其威力所在。</p>
<p>async/await其实是Promise的语法糖，它能实现的效果都能用then链来实现，这也和我们之前提到的一样，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await译为等待，所以我们很好理解async声明function是异步的，await等待某个操作完成。当然语法上强制规定await只能出现在asnyc函数中，我们先来看看async函数返回了什么：</p>
<pre><code class="language-c">async function testAsy(){
   return 'hello world';
}
let result = testAsy(); 
console.log(result)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200310002218223.png" alt="在这里插入图片描述" loading="lazy"><br>
这个async声明的异步函数把return后面直接量通过Promise.resolve()返回Promise对象，所以如果这个最外层没有用await调用的话，是可以用原来then链的方式来调用的：</p>
<pre><code class="language-c">async function testAsy(){
   return 'hello world'
}
let result = testAsy() 
console.log(result)
result.then(v=&gt;{
    console.log(v)   //hello world
})
</code></pre>
<p>联想一下Promise特点——异步无等待，所以当没有await语句执行async函数，它就会立即执行，返回一个Promise对象，非阻塞，与普通的Promise对象函数一致。</p>
<p>以下是一个promise在1s之后resolve的例子：</p>
<pre><code class="language-c">async function f() {
    let promise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; resolve('done!'), 1000)
    })
    let result = await promise // 直到promise返回一个resolve值（*）
    console.log(result) 
}
f()
</code></pre>
<p>函数执行到（*）行会‘暂停’，当promise处理完成后重新恢复运行， resolve的值成了最终的result，所以上面的代码会在1s后输出'done!'</p>
<p>我们强调一下：await字面上使得JavaScript等待，直到promise处理完成，</p>
<p>然后将结果继续下去。这并不会花费任何的cpu资源，因为引擎能够同时做其他工作：执行其他脚本，处理事件等等。</p>
<p>这只是一个更优雅的得到promise值的语句，它比promise更加容易阅读和书写。</p>
<p>如果去掉await，我们获得的就是一个promise对象。</p>
<pre><code class="language-c">//加上await
done!

//没有await
Promise {&lt;pending&gt;}
__proto__: Promise
[[PromiseStatus]]: &quot;resolved&quot;
[[PromiseValue]]: &quot;done!&quot;
</code></pre>
<p><strong>重点就在await，它等待什么呢？</strong></p>
<p>按照语法说明，await等待的是一个Promise对象，或者是其他值（也就是说可以等待任何值），如果等待的是Promise对象，则返回Promise的处理结果；如果是其他值，则返回该值本身。并且await会暂停当前async function的执行，等待Promise的处理完成。若Promise正常处理（fulfillded），其将回调的resolve函数参数作为await表达式的值，继续执行async function；若Promise处理异常（rejected），await表达式会把Promise异常原因抛出；另外如果await操作符后面的表达式不是一个Promise对象，则返回该值本身。</p>
<h2 id="2-深入理解asyncawait">2. 深入理解async/await</h2>
<p>我们来详细说明一下async/await的作用。await操作符后面可以是任意值，当是Promise对象的时候，会暂停async function执行。也就是说，必须得等待await后面的Promise处理完成才能继续：</p>
<pre><code class="language-c"> function testAsy(x){
   return new Promise(resolve=&gt;{setTimeout(() =&gt; {
       resolve(x);
     }, 3000)
    }
   )
}
async function testAwt(){    
  let result =  await testAsy('hello world');
  console.log(result);    // 3秒钟之后出现hello world
}
testAwt();
</code></pre>
<p>await 表达式的运算结果取决于它等的东西。</p>
<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>
<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>
<p>我们再把上面的代码修改一下，好好体会“阻塞”这个词</p>
<pre><code class="language-c"> function testAsy(x){
   return new Promise(resolve=&gt;{setTimeout(() =&gt; {
       resolve(x);
     }, 3000)
    }
   )
}
async function testAwt(){    
  let result =  await testAsy('hello world');
  console.log(result);    // 3秒钟之后出现hello world
  console.log('Y')   // 3秒钟之后出现Y
}
testAwt();
console.log('L')  //立即输出L
</code></pre>
<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'tangSir''最先输出，hello world'和‘tangj’是3秒钟后同时出现的。</p>
<blockquote>
<p>为什么会立即输出L，这就涉及到了JS中的事件循环了，我写了一篇关于事件循环的博客，看了应该会明白，总的来说，异步函数会在非异步函数之后运行。</p>
</blockquote>
<h2 id="3-async和await简单应用">3. async和await简单应用</h2>
<p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>
<p>现在举例，用 setTimeout模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p>
<pre><code class="language-c">function takeLongTime() {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);
    });
}

takeLongTime().then(v =&gt; {
    console.log(&quot;got&quot;, v); //一秒钟后输出got long_time_value
});
</code></pre>
<p>如果改用 async/await 呢，会是这样</p>
<pre><code class="language-c">function takeLongTime() {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);
    });
}

async function test() {
    const v = await takeLongTime();
    console.log(v);  // 一秒钟后输出long_time_value
}

test();
</code></pre>
<p>tankLongTime()本身就是返回的 Promise 对象，所以加不加 async结果都一样。</p>
<h2 id="4-处理then链">4. 处理then链</h2>
<p>前面我们说了，async和await是处理then链的语法糖，现在我们来看看具体是怎么实现的：</p>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用setTimeout来模拟异步操作：</p>
<pre><code class="language-c">/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(n + 200), n);
    });
}

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}

function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
</code></pre>
<p>现在用 Promise 方式来实现这三个步骤的处理。</p>
<pre><code class="language-c">function doIt(){
    console.time('doIt');
    let time1 = 300;
    step1(time1)
        .then((time2) =&gt; step2(time2))
        .then((time3) =&gt; step3(time3))　　
        .then((result) =&gt; {
            console.log(`result is ${result}`);
            console.timeEnd(&quot;doIt&quot;);
        })
}

doIt();

//执行结果为:
//step1 with 300
//step2 with 500
//step3 with 700
//result is 900
//doIt: 1510.2490234375ms
</code></pre>
<p>输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。</p>
<p>如果用 async/await 来实现呢，会是这样：</p>
<pre><code class="language-c">async function doIt() {
    console.time('doIt');
    let time1 = 300;
    let time2 = await step1(time1);//将Promise对象resolve(n+200)的值赋给time2
    let time3 = await step1(time2);
    let result = await step1(time3);
    console.log(`result is ${result}`);
    console.timeEnd('doIt');
}

doIt();

//执行结果为:
//step1 with 300
//step2 with 500
//step3 with 700
//result is 900
//doIt: 1512.904296875ms
</code></pre>
<p>显然我们用async/await简单多了。</p>
<h2 id="5-promise处理结果为rejected">5. Promise处理结果为rejected</h2>
<p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。</p>
<pre><code class="language-c">async function myFunction() {
    try {
        await somethingThatReturnAPromise();
    } catch (err){
        console.log(err);
    }
}

//另一种写法
async function myFunction() {
    await somethingThatReturnAPromise().catch(function(err) {
        console.log(err);
    })
}
</code></pre>
<h2 id="6实例">6.实例</h2>
<p><strong>Vue普通写法：</strong></p>
<pre><code class="language-c">methods: {
     getLocation(phoneNum) {
         return axios.post('/mm接口', {
             phoneNum
         })
     },    
     getFaceList(province, city) {
         return axios.post('/nn接口', {
             province,
             city
         })
     },  
     getFaceResult () {
          this.getLocation(this.phoneNum).then(res =&gt; {
              if (res.status === 200 &amp;&amp; res.data.success) {
              let province = res.data.obj.province;
              let city = res.data.obj.city;
                  this.getFaceList(province, city).then(res =&gt; {
                        if(res.status === 200 &amp;&amp; res.data.success) {
                             this.faceList = res.data.obj
                        }
                  })
              }
         }).catch(err =&gt; {
             console.log(err)
         })     
     }
}
</code></pre>
<p>这时你看到了then 的链式写法，有一点回调地域的感觉。现在我们在有async/ await 来改造一下。</p>
<p><strong>加入async/ await：</strong></p>
<p>首先把 getFaceResult 转化成一个async 函数，就是在其前面加async， 因为它的调用方法和普通函数的调用方法是一致，所以没有什么问题。然后就把 getLocation 和getFaceList 放到await 后面，等待执行， getFaceResult  函数修改如下：</p>
<pre><code class="language-c">async getFaceResult () {
                let location = await this.getLocation(this.phoneNum);
                if (location.data.success) {
                    let province = location.data.obj.province;
                    let city = location.data.obj.city;
                    let result = await this.getFaceList(province, city);
                    if (result.data.success) {
                        this.faceList = result.data.obj;
                    }
                }
            }
</code></pre>
<p>现在代码的书写方式，就像写同步代码一样，没有回调的感觉，非常舒服。</p>
<p>现在就还差一点需要说明，那就是怎么处理异常，如果请求发生异常，怎么处理？ 它用的是try/catch 来捕获异常，把await 放到 try 中进行执行，如有异常，就使用catch 进行处理。</p>
<pre><code class="language-c">async getFaceResult () {
                try {
                    let location = await this.getLocation(this.phoneNum);
                    if (location.data.success) {
                        let province = location.data.obj.province;
                        let city = location.data.obj.city;
                        let result = await this.getFaceList(province, city);
                        if (result.data.success) {
                            this.faceList = result.data.obj;
                        }
                    }
                } catch(err) {
                    console.log(err);
                }
            }
</code></pre>
<h2 id="注">注：</h2>
<blockquote>
<p>ES7引入的关键字async/await是对JavaScript异步编程的改进。它可以使代码更容易阅读和调试。然而，为了正确使用它们，必须完全理解promise，因为它们只不过是语法糖，而潜在的技术仍然是promise。</p>
</blockquote>
<h2 id="思考">思考：</h2>
<p>Vue中，async created()这种写法有什么用呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（八）：解构赋值]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptba-jie-gou-fu-zhi/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptba-jie-gou-fu-zhi/">
        </link>
        <updated>2020-05-18T03:33:40.000Z</updated>
        <content type="html"><![CDATA[<p>ES6解构：es6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称之为解构。</p>
<p>解构赋值是对赋值运算符的扩展。</p>
<p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p>
<h2 id="解构模型">解构模型</h2>
<p>在解构中，有下面两部分参与：</p>
<p>1.解构的源，解构赋值表达式的右边部分。</p>
<p>2.解构的目标，解构赋值表达式的左边部分。</p>
<h2 id="解构赋值">解构赋值</h2>
<p><strong>1.数组的解构赋值</strong></p>
<pre><code class="language-c">var [a,b,c] = [1,2,3];
console.log(a);//1
console.log(b);//2
console.log(c);//3
//本质上这种写法属于‘模式匹配‘，只要等号两边的模式相同，左边的变量就会被赋予对应的值
let [foo,[bar]] = [&quot;111&quot;,[&quot;abc&quot;]];
console.log(bar); //abc

let [, ,third] = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;];
console.log(third); //baz

let [x,y,z] = ['hah'];
console.log(y); //undefined
//如果解构不成功，变量的值就等于undefined
</code></pre>
<p>解构一般有三种情况，完全解构，不完全解构，解构不成功,在上述例子中存在完全解构和解构不成功的例子，下面来看一下不完全解构的例子</p>
<pre><code class="language-c">let [x,y] = [1,2,3];
console.log(x); //1
console.log(y); //2
let [a,[b],d] = [1,[2,3],4];
console.log(a); //1
console.log(b); //2
console.log(d); //4
//不完全解构：即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下解构依然成功
</code></pre>
<pre><code class="language-c">//如果等号的右边不是数组，或者说不是可遍历的结构，那么将会报错
let [a] = 1;
let [b] = false;
let [c] = NaN;
let [d] = undefined;
let [e] = null;
let [f] = {};
//上面的语句都会报错：Uncaught TypeError: 1 is not iterable
</code></pre>
<p><strong>2. 默认值</strong></p>
<p>解构赋值允许指定默认值</p>
<pre><code class="language-c">let [x,y='b'] = ['a'];
console.log(y); //b

let [x,y = 'b'] = ['a',undefined];
console.log(y); //b ,数组成员为undefined时，默认值仍会生效(因为在ES6内部使用严格相等运算符‘===‘，判断一个位置是否有值，所以当一个数组成员严格等于undefined,默认值才会生效)

let [x,y = 'b'] = ['a',null];
console.log(y); //null,如果一个数组成员是null,默认值就不会生效，因为null不严格等于undefined
</code></pre>
<p><strong>3. 对象的解构赋值</strong></p>
<p>对象的解构与数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>
<pre><code class="language-c"> //1. 变量名与属性名一致的情况下
 let {foo,bar} = {foo : &quot;aaa&quot;,bar : &quot;bbb&quot;}
 console.log(foo); //aaa
 console.log(bar); //bbb
 //变量名与属性名不一致的情况下，必须这样写
 let {a : name, b : age} = {a : 'zhangsan', b : 33};
 console.log(name); //zhangsan
 console.log(age);  //33
</code></pre>
<p>实际上 对象的解构赋值是以这样的形式简写的</p>
<pre><code class="language-c"> let {foo : foo ,bar : bar} = {foo : &quot;aaa&quot;,bar : &quot;bbb&quot;}
</code></pre>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者，第一个foo/bar 是匹配的模式，对应的foo/bar属性值才是变量，真正被赋值的是属性值（也就是第二个foo/bar), 如果不能理解再看下面这个例子</p>
<pre><code class="language-c">const node = {
    grand : {
        father : {
            line : 1,
            column : 5
        }
    }
 }

 let {grand,grand : { father},grand : {father : {column}}} = node;
 console.log(father); // {line : 1, column : 5}
 console.log(column); // 5
 // grand、fahter、column 分别对这三个属性解构赋值，grand、father是模式，只有column 是变量
</code></pre>
<p><strong>4. 字符串的解构赋值</strong></p>
<pre><code class="language-c">const [a,b,c,d,e] = 'hello';
console.log(a); //h
console.log(b); //e
console.log(c); //l
console.log(d); //l
console.log(e); //o

let { length : len} = 'yahooa';
console.log(len); //5,类似数组的对象都有一个length属性，还可以对这个属性解构赋值
</code></pre>
<ol>
<li>数值和布尔值的解构赋值<br>
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，但是等号右边为undefined 和 null时无法转为对象，所以对他们进行解构赋值时，都会报错</li>
</ol>
<pre><code class="language-c">let {prop : x } = undefined;
console.log(x); //报错：Uncaught TypeError: Cannot destructure property `prop` of 'undefined' or 'null'
</code></pre>
<p><strong>6.函数参数的解构赋值</strong></p>
<p>函数的参数也可以使用解构参数</p>
<pre><code class="language-c">function move({x = 0,y = 0} = { }){
    return [x,y];
 }
console.log(move({x : 3,y : 4})); //[3,4]
console.log(move({x : 3})); //[3,0]
console.log(move({})); //[0,0]
console.log(move()); //[0,0]
//move()的参数是一个对象，通过对这个对象进行解构，得到变量x、y的值，如果解构失败，x和y 等于默认值
function move2({x,y} = {x : 1, y : 2 }){
    return [x,y];
}
console.log(move2({x : 6,y : 8})); //[6,8]
console.log(move2({})); //[undefined,undefined]
console.log(move2()); //[1,2]
//move2() 是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以与前一种写法的结果不太一样，undefined 就会触发函数的默认值
</code></pre>
<p><strong>7.对象解构中的 Rest</strong></p>
<pre><code class="language-c">let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}
a; // 10 
b; // 20 
rest; // { c: 30, d: 40 }
</code></pre>
<p><strong>8.解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</strong></p>
<pre><code class="language-c">// 声明对象 和 自身 self 属性
var obj = {self: '123'};
// 在原型链中定义一个属性 prot
obj.__proto__.prot = '456';
// test
const {self, prot} = obj;
// self &quot;123&quot;
// prot &quot;456&quot;（访问到了原型链）
</code></pre>
<h2 id="解构用途">解构用途</h2>
<p><strong>1.交换变量的值</strong></p>
<pre><code class="language-c">let x = 1;
let y = 2;
[x,y] = [y,x];
console.log(x); //2
console.log(y); //1
</code></pre>
<p><strong>2.从函数返回多个值</strong><br>
函数只能返回一个值，如果要返回多个值的话，只能将它们放在数组或者对象里返回</p>
<pre><code class="language-c">function example(){
   return {
       foo : 'a',
       bar : 'b'
   }
 }
 let {foo,bar} = example();
 console.log(foo); //a
 console.log(bar); //b
</code></pre>
<p><strong>3. 函数参数的定义</strong></p>
<pre><code class="language-c">//参数是一组有次序的值
function example([x,y,z]){
    return x + y + z;
}
example([1,2,3])
console.log(example([1,2,3])); //6
//参数是一组无次序的值
function f({x,y,z}){
    return x + y + z;
}
f({x : 'a', z : 'b', y : 'c' });

console.log(f({x : 'a', z : 'b', y : 'c' })); //acb
1
</code></pre>
<p><strong>4.提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code class="language-c">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre>
<p><strong>5.函数参数的默认值</strong></p>
<pre><code class="language-c">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。</p>
<p><strong>6.遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="language-c">const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
如果只想获取键名，或者只想获取键值，可以写成下面这样。

// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre>
<p><strong>7.输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code class="language-c">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（七）：Generator]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptqi-generator/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptqi-generator/">
        </link>
        <updated>2020-05-18T03:33:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5generator">1.为什么要引入Generator？</a></li>
<li><a href="#2%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">2.基本用法</a></li>
<li><a href="#3yield">3.yield</a></li>
<li><a href="#4yield">4.yield*</a></li>
<li><a href="#5next%E6%96%B9%E6%B3%95">5.next()方法</a></li>
<li><a href="#6next%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0">6.next()方法的参数</a></li>
<li><a href="#7throw%E6%96%B9%E6%B3%95">7.throw方法()</a></li>
<li><a href="#8return%E6%96%B9%E6%B3%95">8.return()方法</a></li>
<li><a href="#9generator%E4%B8%AD%E7%9A%84this%E5%92%8C%E4%BB%96%E7%9A%84%E5%8E%9F%E5%9E%8B">9.Generator中的this和他的原型</a></li>
<li><a href="#10%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">10.实际应用</a></li>
<li><a href="#11%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87">11.时间切片</a></li>
<li><a href="#%E6%B3%A8">注：</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1为什么要引入generator">1.为什么要引入Generator？</h2>
<p>众所周知，传统的JavaScript异步的实现是通过回调函数来实现的，但是这种方式有两个明显的缺陷：</p>
<p>1.缺乏可信任性。例如我们发起ajax请求的时候是把回调函数交给第三方进行处理，期待它能执行我们的回调函数，实现正确的功能<br>
2.缺乏顺序性。众多回调函数嵌套使用，执行的顺序不符合我们大脑常规的思维逻辑，回调逻辑嵌套比较深的话调试代码时可能会难以定位。</p>
<p>Promise恢复了异步回调的可信任性，而Generator正是以一种看似顺序、同步的方式实现了异步控制流程，增强了代码可读性。</p>
<p>generator是ES6提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行generator，会生成返回一个遍历器对象。返回的遍历器对象，可以依次遍历generator函数的每一个状态。同时ES6规定这个遍历器是Generator函数的实例，也继承了Genarator函数的prototype对象上的方法。</p>
<p><strong>Generator 函数是一个普通函数，但是有两个特征。</strong></p>
<p>一是，function关键字与函数名之间有一个星号；<br>
二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h2 id="2基本用法">2.基本用法</h2>
<p>Generator(生成器)是一类特殊的函数，跟普通函数声明时的区别是加了一个*号。</p>
<p>Iterator(迭代器)：当我们实例化一个生成器函数之后，这个实例就是一个迭代器。可以通过next()方法去启动生成器以及控制生成器的是否往下执行。</p>
<p>yield/next：这是控制代码执行顺序的一对好基友。通过yield语句可以在生成器函数内部暂停代码的执行使其挂起，此时生成器函数仍然是运行并且是活跃的，其内部资源都会保留下来，只不过是处在暂停状态。在迭代器上调用next()方法可以使代码从暂停的位置开始继续往下执行。</p>
<pre><code class="language-c">function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();

hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'ending', done: true }

hw.next()
// { value: undefined, done: true }
</code></pre>
<p>上面的程序执行了四次next：</p>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p>
<h2 id="3yield">3.yield</h2>
<p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>
<p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p>
<p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p>
<p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p>
<p>（4）如果该函数没有return语句或者执行完return之后再运行next的时候，则返回的对象的value属性值为undefined,done为true。</p>
<p><strong>注意：</strong><br>
需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。<br>
yield表达式如果用在另一个表达式之中，必须放在圆括号里面<br>
yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。<br>
yield放在表达式中的时候，let s =（yield 1+2），s其值将会是undefined，而1+2这个等于3的值将会作为next返回对象的value的值</p>
<p>Generator函数返回的Iterator运行的过程中，如果碰到了yield， 就会把yield后面的值返回， 此时函数相当于停止了， 下次再执行next()方法的时候， 函数又会从上次退出去的地方重新开始执行；</p>
<p>如果把yield和return一起使用的话， 那么return的值也会作为最后的返回值， 如果return语句后面还有yield， 那么这些yield不生效：</p>
<pre><code class="language-c">function* gen() {
    yield 0;
    yield 1;
    return 2;
    yield 3;
};
let g = gen();
console.log(g.next(),g.next(),g.next(),g.next());
//输出：{ value: 0, done: false } { value: 1, done: false } { value: 2, done: true } { value: undefined, done: true }
</code></pre>
<h2 id="4yield">4.yield*</h2>
<p>yield<em>这种语句让我们可以在Generator函数里面再套一个Generator， 当然你要在一个Generator里面调用另外的Generator需要使用: yield</em> 函数() 这种语法， 都是套路啊：</p>
<pre><code class="language-c">function* foo() {
    yield 0;
    yield 1;
}
function* bar() {
    yield 'x';
    yield* foo();
    yield 'y';
}
for (let v of bar()){
    console.log(v);
};
//依次输出x，0，1，y
</code></pre>
<h2 id="5next方法">5.next()方法</h2>
<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<p>这个参数就是解决了上面说的注意事项的最后一个，yield的返回值总是undefined，</p>
<p>由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</p>
<p>Generator函数返回的Iterator执行next()方法以后， 返回值的结构为：</p>
<pre><code class="language-c">{
    value : &quot;value&quot;, //value为返回的值
    done : false //done的值为一个布尔值， 如果Interator未遍历完毕， 他会返回false， 否则返回true；
}
 
</code></pre>
<p>所以我们可以模拟一个Generator生成器， 利用闭包保存变量， 每一次执行next()方法， 都模拟生成一个{value:value,done:false}的键值对：</p>
<pre><code class="language-c">function gen(array){
    var nextIndex = 0;
    return {
        next: function(){
            return nextIndex &lt; array.length ?
            {value: array[nextIndex++], done: false} :
            {value: undefined, done: true};
        }
    };
};

var it = gen([&quot;arr0&quot;, &quot;arr1&quot;, &quot;arr2&quot;, &quot;arr3&quot;]);
console.log( it.next() );
console.log( it.next() );
console.log( it.next() );
console.log( it.next() );
console.log( it.next() );　
</code></pre>
<h2 id="6next方法的参数">6.next()方法的参数</h2>
<p>如果给next方法传参数， 那么这个参数将会作为上一次yield语句的返回值 ，这个特性在异步处理中是非常重要的， 因为在执行异步代码以后， 有时候需要上一个异步的结果， 作为下次异步的参数， 如此循环：：</p>
<pre><code class="language-c">&lt;script&gt;
function* foo(x) {
    var y = 2 * (yield (x + 1));
    var z = yield (y / 3);
    return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
&lt;/script&gt;
</code></pre>
<h2 id="7throw方法">7.throw方法()</h2>
<p>如果执行Generator生成器的throw()方法， 如果在Iterator执行到的yield语句写在try{}语句块中， 那么这个错误会被内部的try{}catch(){}捕获 ：</p>
<pre><code class="language-c">&lt;script&gt;
var g = function* () {
    try {
        yield;
    } catch (e) {
        console.log('内部捕获0', e);
    }
};

var i = g();
i.next(); //让代码执行到yield处；
try {
    i.throw('a');
} catch (e) {
    console.log('外部捕获', e);
}
&lt;/script&gt;
</code></pre>
<h2 id="8return方法">8.return()方法</h2>
<p>如果执行Iterator的return()方法， 那么这个迭代器的返回会被强制设置为迭代完毕， 执行return()方法的参数就是这个Iterator的返回值，此时done的状态也为true：</p>
<pre><code class="language-c">&lt;script&gt;
function* gen() {
    yield 0;
    yield 1;
    yield 2;
    yield 3;
};
let g = gen();
console.log(g.return(&quot;heheda&quot;)); //输出：{ value: 'heheda', done: true }
&lt;/script&gt;
</code></pre>
<h2 id="9generator中的this和他的原型">9.Generator中的this和他的原型</h2>
<p>Generator中的this就是谁调用它，那么this就是谁， 我们利用Reflect.apply可以改变Generator的上下文：</p>
<pre><code class="language-c">function* gen() {
    console.log(this);
    yield 0;
};
console.log(gen().next());
console.log(Reflect.apply(gen,&quot;heheda&quot;).next());
</code></pre>
<h2 id="10实际应用">10.实际应用</h2>
<p><strong>1.比如抽奖环节，当前用户还可以抽奖5次。点击后次数减1。</strong></p>
<p>若采用ES5的方式，不使用Generator，则需要将count存入全局变量中，但是这样非常不安全，如果别人知道变量是什么，就可以修改变量；另外存入全局变量也会影响性能。</p>
<pre><code class="language-c">{
    let draw=function(count){
        //具体抽奖逻辑，跟次数的校验是分开的
        //输出剩余次数
        console.log(`剩余${count}次`)
    }
　　 //利用Generator控制次数
    let residue=function*(count){
        while(count&gt;0){
            count--
            yield draw(count)
        }
    }
　　//将Generator实例化，通过按钮绑定，点击执行next，进行抽奖
    let star=residue(5)
    let btn=document.createElement('button')
    btn.id='start'
    btn.textContent='抽奖'
    document.body.appendChild(btn)
    document.getElementById('start').addEventListener('click',function(){
        star.next()
    },false)
}
</code></pre>
<p><strong>2.长轮询</strong></p>
<p>场景：服务端的某一个数据状态定期变化，前端需要定时的去服务端取这个状态</p>
<p>对于这种场景，有两种解决方案</p>
<p>1）长轮询（定时器，定时访问接口）</p>
<p>2）websocket（浏览器兼容性不好）</p>
<pre><code class="language-c">{
	let ajax=function* (){
		yield new Promise(function(resolve,reject){
			setTimeout(function(){
				resolve({code:0})
			},200)
		})
	}
 
	let pull=function(){
		let generator=ajax()
		let step=generator.next()
		step.value.then(function(d){
			if(d.code!=0){
				setTimeout(function(){
					console.log('wait')
					pull()
				},1000)
			}else{
				console.log(d)
			}
		})
	}
 
	pull()
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-c">{code: 0}
</code></pre>
<p>将resolve({code:0})中code改成1,会一直轮询，输出结果为</p>
<pre><code class="language-c">wait
wait
wait
...
　　
</code></pre>
<h2 id="11时间切片">11.时间切片</h2>
<p>时间切片的核心思想是：如果任务不能在50毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。</p>
<p>所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过50ms的小任务分散在宏任务队列中执行。</p>
<pre><code class="language-JavaScript">btn.onclick = ts(function* () {
  someThing(); // 执行了50毫秒
  yield;
  otherThing(); // 执行了50毫秒
});

</code></pre>
<h2 id="注">注：</h2>
<p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<p>1.回调函数。<br>
2.事件监听。<br>
3.发布/订阅。<br>
4.Promise 对象。</p>
<p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript（六）：Promise]]></title>
        <id>https://dark-yifeng.github.io/post/javascriptliu-promise/</id>
        <link href="https://dark-yifeng.github.io/post/javascriptliu-promise/">
        </link>
        <updated>2020-05-18T03:32:30.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E5%AE%9A%E4%B9%89">1.定义</a></li>
<li><a href="#2%E4%BD%9C%E7%94%A8">2.作用</a></li>
<li><a href="#3%E8%AF%AD%E6%B3%95">3.语法</a></li>
<li><a href="#4%E7%8A%B6%E6%80%81">4.状态</a></li>
<li><a href="#5%E6%96%B9%E6%B3%95">5.方法</a></li>
<li><a href="#6%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95">6.原型方法</a></li>
<li><a href="#7catch%E6%96%B9%E6%B3%95">7.catch()方法</a></li>
<li><a href="#8%E5%AE%9E%E4%BE%8B">8.实例</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1定义">1.定义</h2>
<p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>
<h2 id="2作用">2.作用</h2>
<p>1、主要用于异步计算。<br>
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。<br>
3、可以在对象之间传递和操作promise，帮助我们处理队列。</p>
<h2 id="3语法">3.语法</h2>
<pre><code class="language-c">new Promise( function(resolve, reject) {...} /* executor */  );
</code></pre>
<h2 id="4状态">4.状态</h2>
<p>一个 Promise有以下几种状态:</p>
<p>1.pending: 初始状态，既不是成功，也不是失败状态。<br>
2.fulfilled: 意味着操作成功完成。<br>
3.rejected: 意味着操作失败。</p>
<p>Promise对象的状态改变，只有两种可能：</p>
<p>1.从pending变为fulfilled<br>
2.从pending变为rejected。</p>
<p>这两种情况只要发生，状态就凝固了，不会再变了。</p>
<pre><code class="language-c">new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre>
<p>pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p>
<p>因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。<br>
<img src="https://img-blog.csdnimg.cn/2020031122192174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlpZmVuZzAwMDA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>示例一：</strong></p>
<pre><code class="language-c">new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve('hello')
  }, 2000)
}).then(res =&gt; {
  console.log(res) //hello
})
</code></pre>
<p><strong>示例二：</strong></p>
<pre><code class="language-c">new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve('hello')
    }, 2000)
  }).then(val =&gt; {
    console.log(val) //  参数val = 'hello'
    return new Promise(resolve =&gt; {
      setTimeout(() =&gt; {
        resolve('world')
      }, 2000)
    })
  }).then(val =&gt; {
    console.log(val) // 参数val = 'world'
  })
</code></pre>
<p><strong>示例三：</strong></p>
<pre><code class="language-c">let pro = new Promise(resolve =&gt; {
   setTimeout(() =&gt; {
     resolve('hello world')
   }, 2000)
 })
 setTimeout(() =&gt; {
   pro.then(value =&gt; {
   console.log(value) // hello world
 })
 }, 2000)
</code></pre>
<blockquote>
<p>promise作为队列最为重要的特性，我们在任何一个地方生成了一个promise队列之后，我们可以把他作为一个变量传递到其他地方。</p>
</blockquote>
<h2 id="5方法">5.方法</h2>
<p><strong>1.Promise.all(iterable)</strong><br>
这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。</p>
<p><strong>2.Promise.race(iterable)</strong><br>
当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p>
<p><strong>3.Promise.reject(reason)</strong><br>
返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法。</p>
<p><strong>4.Promise.resolve(value)</strong><br>
返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p>
<h2 id="6原型方法">6.原型方法</h2>
<p><strong>1.Promise.prototype.catch(onRejected)</strong><br>
添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果。</p>
<p><strong>2.Promise.prototype.then(onFulfilled, onRejected)</strong><br>
添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.</p>
<p><strong>3.Promise.prototype.finally(onFinally)</strong><br>
添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)</p>
<h2 id="7catch方法">7.catch()方法</h2>
<p>Promise.prototype.catch 方法是 .then(null, rejection) 或是 .then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>如果Promise 对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code class="language-c">p.then((val) =&gt; console.log('fulfilled:', val))
  .catch((err) =&gt; console.log('rejected', err));

// 等同于
p.then((val) =&gt; console.log('fulfilled:', val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
  
</code></pre>
<h2 id="8实例">8.实例</h2>
<p>本例展示了 Promise 的一些机制。 testPromise() 方法在每次点击 <button> 按钮时被调用，该方法会创建一个promise 对象，使用 window.setTimeout() 让Promise等待 1-3 秒不等的时间来填充数据（通过Math.random()方法）。</p>
<p>Promise 的值的填充过程都被日志记录（logged）下来，这些日志信息展示了方法中的同步代码和异步代码是如何通过Promise完成解耦的。</p>
<pre><code class="language-c">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;亦枫&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button onclick=&quot; testPromise()&quot; id=&quot;log&quot;&gt;0.0&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    var promiseCount = 0;
    function testPromise() {
        let thisPromiseCount = ++promiseCount;

        let log = document.getElementById('log');
        log.insertAdjacentHTML('beforeend', thisPromiseCount +
            ') 开始 (&lt;small&gt;同步代码开始&lt;/small&gt;)&lt;br/&gt;');

        // 新构建一个 Promise 实例：使用Promise实现每过一段时间给计数器加一的过程，每段时间间隔为1~3秒不等
        let p1 = new Promise(
            // resolver 函数在 Promise 成功或失败时都可能被调用
            (resolve, reject) =&gt; {
                log.insertAdjacentHTML('beforeend', thisPromiseCount +
                    ') Promise 开始 (&lt;small&gt;异步代码开始&lt;/small&gt;)&lt;br/&gt;');
                // 创建一个异步调用
                window.setTimeout(
                    function () {
                        // 填充 Promise
                        resolve(thisPromiseCount);
                    }, Math.random() * 2000 + 1000);
            }
        );

        // Promise 不论成功或失败都会调用 then
        // catch() 只有当 promise 失败时才会调用
        p1.then(
                // 记录填充值
                function (val) {
                    log.insertAdjacentHTML('beforeend', val +
                        ') Promise 已填充完毕 (&lt;small&gt;异步代码结束&lt;/small&gt;)&lt;br/&gt;');
                })
            .catch(
                // 记录失败原因
                (reason) =&gt; {
                    console.log('处理失败的 promise (' + reason + ')');
                });

        log.insertAdjacentHTML('beforeend', thisPromiseCount +
            ') Promise made (&lt;small&gt;同步代码结束&lt;/small&gt;)&lt;br/&gt;');
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>效果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200311224346441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlpZmVuZzAwMDA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>刨析promise的内部机构，这篇文章写得不错：</p>
<p>https://github.com/xieranmaya/blog/issues/3</p>
]]></content>
    </entry>
</feed>