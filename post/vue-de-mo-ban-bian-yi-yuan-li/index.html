<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vue：15个最佳做法 | Dark</title>
<link rel="shortcut icon" href="https://dark-yifeng.github.io/favicon.ico?v=1589795136349">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dark-yifeng.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Vue：15个最佳做法 | Dark - Atom Feed" href="https://dark-yifeng.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="


1.始终在 v-for 中使用 :key
2.在事件中使用短横线命名
3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props
4.data 应始终返回一个函数
5. 不要在同个元素上同时使用v-if和v-for指令..." />
    <meta name="keywords" content="Vue" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dark-yifeng.github.io">
  <img class="avatar" src="https://dark-yifeng.github.io/images/avatar.png?v=1589795136349" alt="">
  </a>
  <h1 class="site-title">
    Dark
  </h1>
  <p class="site-description">
    克己，执着，努力，疯狂，谦卑
  </p>
  <div class="menu-container">
    
      
        <a href="https://dark-yifeng.github.io" class="menu">
          主页
        </a>
      
    
      
        <a href="https://dark-yifeng.github.io/tags" class="menu">
          分类
        </a>
      
    
      
        <a href="https://dark-yifeng.github.io/archives" class="menu">
          日期
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Dark-YiFeng" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Vue：15个最佳做法
            </h2>
            <div class="post-info">
              <span>
                2020-05-18
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://dark-yifeng.github.io/tag/74z3KqTAN/" class="post-tag">
                  # Vue
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E5%A7%8B%E7%BB%88%E5%9C%A8-v-for-%E4%B8%AD%E4%BD%BF%E7%94%A8-key">1.始终在 v-for 中使用 :key</a></li>
<li><a href="#2%E5%9C%A8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D">2.在事件中使用短横线命名</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A3%B0%E6%98%8E-props%E5%B9%B6%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D%E6%9D%A5%E8%AE%BF%E9%97%AE-props">3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props</a></li>
<li><a href="#4data-%E5%BA%94%E5%A7%8B%E7%BB%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">4.data 应始终返回一个函数</a></li>
<li><a href="#5-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%90%8C%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8A%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-for%E6%8C%87%E4%BB%A4">5. 不要在同个元素上同时使用v-if和v-for指令</a></li>
<li><a href="#6%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%88%91%E4%BB%AC%E7%9A%84-props">6.用正确的定义验证我们的 props</a></li>
<li><a href="#7%E7%BB%84%E4%BB%B6%E5%85%A8%E5%90%8D%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E6%88%96%E6%88%96%E8%80%85%E7%9F%AD%E6%A8%AA%E7%BA%BF">7.组件全名使用驼峰或或者短横线</a></li>
<li><a href="#8-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E7%9B%B8%E5%BA%94%E5%9C%B0%E5%8A%A0%E4%B8%8A%E5%89%8D%E7%BC%80">8. 基本组件应该相应地加上前缀</a></li>
<li><a href="#9%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D%E5%BA%94%E8%AF%A5%E5%B8%A6%E6%9C%89%E5%89%8D%E7%BC%80-the">9.单实例组件命名应该带有前缀 The</a></li>
<li><a href="#10%E4%BF%9D%E6%8C%81%E6%8C%87%E4%BB%A4%E7%AE%80%E5%86%99%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">10.保持指令简写的一致性</a></li>
<li><a href="#11%E4%B8%8D%E8%A6%81%E5%9C%A8created%E5%92%8Cwatch%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">11.不要在“created”和“watch”中调用方法</a></li>
<li><a href="#12-%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E8%AF%A5%E5%8F%AA%E6%9C%89%E5%9F%BA%E6%9C%AC%E7%9A%84-js-%E8%A1%A8%E8%BE%BE%E5%BC%8F">12. 模板表达式应该只有基本的 JS 表达式</a></li>
<li><a href="#13%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%9B%B4%E6%96%B0">13.路由参数变化组件不更新</a></li>
<li><a href="#14%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD">14.路由懒加载</a></li>
<li><a href="#15%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D">15.自定义路径别名</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1始终在-v-for-中使用-key">1.始终在 v-for 中使用 :key</h2>
<p>在需要操纵数据时，将key属性与v-for指令一起使用可以让程序保持恒定且可预测。</p>
<p>这是很有必要的，这样Vue就可以跟踪组件状态，并对不同的元素有一个常量引用。在使用动画或Vue转换时，key 非常有用。</p>
<p>如果没有key ，Vue只会尝试使DOM尽可能高效。 这可能意味着v-for中的元素可能会出现乱序，或者它们的行为难以预测。 如果我们对每个元素都有唯一的键引用，那么我们可以更好地预测Vue应用程序将如何精确地处理DOM操作。</p>
<h2 id="2在事件中使用短横线命名">2.在事件中使用短横线命名</h2>
<p>在发出定制事件时，最好使用短横线命名，这是因为在父组件中，我们使用相同的语法来侦听该事件。</p>
<p>因此，为了确保我们各组件之间的一致性，并使您的代码更具可读性，请在两个地方都坚持使用短横线命名。</p>
<pre><code class="language-c">this.$emit('close-window')
// 在父组件中
&lt;popup-window @close-window='handleEvent()' /&gt;
</code></pre>
<h2 id="3使用驼峰式声明-props并在模板中使用短横线命名来访问-props">3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props</h2>
<p>最佳做法只是遵循每种语言的约定。 在 JS 中，驼峰式声明是标准，在HTML中，是短横线命名。 因此，我们相应地使用它们。</p>
<p>幸运的是，Vue 已经提供了驼峰式声明和短横线命名之间转换，因此除了实际声明它们之外，我们不必担心任何事情。</p>
<pre><code class="language-c">// 不好的做法
&lt;PopupWindow titleText='hello world' /&gt; 
props: { 'title-text': String }
// 好的做法
&lt;PopupWindow title-text='hello world' /&gt; 
props: { titleText: String }
</code></pre>
<h2 id="4data-应始终返回一个函数">4.data 应始终返回一个函数</h2>
<p>声明组件data时，data选项应始终返回一个函数。 如果返回的是一个对象，那么该data将在组件的所有实例之间共享。</p>
<pre><code class="language-c">// 不好的做法
data: {
  name: 'My Window',
  articles: []
}
</code></pre>
<p>但是，大多数情况下，我们的目标是构建可重用的组件，因此我们希望每个组件返回一个惟一的对象。我们通过在函数中返回数据对象来实现这一点。</p>
<pre><code class="language-c">// 好的做法
data () {
  return {
    name: 'My Window',
    articles: []
  }
}
</code></pre>
<h2 id="5-不要在同个元素上同时使用v-if和v-for指令">5. 不要在同个元素上同时使用v-if和v-for指令</h2>
<p>为了过滤数组中的元素，我们很容易将v-if与v-for在同个元素同时使用。</p>
<pre><code class="language-c">// 不好的做法
&lt;div v-for='product in products' v-if='product.price &lt; 500'&gt;
问题是在 Vue 优先使用v-for指令，而不是v-if指令。它循环遍历每个元素，然后检查v-if条件。

this.products.map(function (product) {
  if (product.price &lt; 500) {
    return product
  }
})
</code></pre>
<p>这意味着，即使我们只想渲染列表中的几个元素，也必须遍历整个数组。</p>
<p>这对我们来当然没有任何好处。</p>
<p>一个更聪明的解决方案是遍历一个计算属性，可以把上面的例子重构成下面这样的：</p>
<pre><code class="language-c">&lt;div v-for='product in cheapProducts'&gt;
 
computed: {
  cheapProducts: () =&gt; {
    return this.products.filter(function (product) {
      return product.price &lt; 100
    })
  }
}
</code></pre>
<p>这么做有几个好处：</p>
<p>1.渲染效率更高，因为我们不会遍历所有元素。</p>
<p>2.仅当依赖项更改时，才会重使用过滤后的列表。</p>
<p>3.这写法有助于将组件逻辑从模板中分离出来，使组件更具可读性。</p>
<h2 id="6用正确的定义验证我们的-props">6.用正确的定义验证我们的 props</h2>
<p>这条是很重要，为什么？</p>
<p>在设计大型项目时，很容易忘记用于props的确切格式、类型和其他约定。如果你在一个更大的开发团队中，你的同事不会读心术，所以你要清楚地告诉他们如何使用你的组件。</p>
<p>因此，我们只需编写props验证即可，不必费力地跟踪组件来确定props的格式。</p>
<p>从Vue文档中查看此示例。</p>
<pre><code class="language-c">props: {
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].indexOf(value) !== -1
    }
  }
}
</code></pre>
<h2 id="7组件全名使用驼峰或或者短横线">7.组件全名使用驼峰或或者短横线</h2>
<p>组件的通用命名约定是使用驼峰或短横线。无论我们使用哪个，最重要的是始终保持一致。我认为驼峰方式 效果最好，因为大多数IDE自动完成功能都支持它。</p>
<pre><code class="language-c"># 不好的做法
mycomponent.vue
myComponent.vue
Mycomponent.vue
# 好做法
MyComponent.vue
</code></pre>
<h2 id="8-基本组件应该相应地加上前缀">8. 基本组件应该相应地加上前缀</h2>
<p>根据Vue样式指南，基本组件是仅包含以下内容的组件：</p>
<p>1.HTML 元素。<br>
2.额外的基础组件。<br>
3.第三方的UI组件。</p>
<p>为这些组件命名的最佳实践是为它们提供前缀Base、V或App。同样，只要我们在整个项目中保持一致，可以使用其中任何一种。</p>
<p>BaseButton.vue<br>
BaseIcon.vue<br>
BaseHeading.vue</p>
<p>该命名约定的目的是使基本组件按字母顺序分组在文件系统中。 另外，通过使用webpack导入功能，我们可以搜索与命名约定模式匹配的组件，并将所有组件自动导入为Vue项目中的全局变量。</p>
<h2 id="9单实例组件命名应该带有前缀-the">9.单实例组件命名应该带有前缀 The</h2>
<p>与基本组件类似，单实例组件(每个页面使用一次，不接受任何prop)应该有自己的命名约定。这些组件特定于我们的应用，通常是 footer，header或sider。</p>
<p>该组件只能有一个激活实例。</p>
<p>TheHeader.vue<br>
TheFooter.vue<br>
TheSidebar.vue<br>
ThePopup.vue</p>
<h2 id="10保持指令简写的一致性">10.保持指令简写的一致性</h2>
<p>在Vue开发人员中，一种常见的技术是使用指令的简写。例如：<br>
<br>
@是v-on的简写<br>
: 是 v-bind 的简写<br>
# 是 v-slot 的简写</p>
<p>在vue项目中使用这些缩写是很好的。但是要在整个项目中创建某种约定，总是使用它们或从不使用它们,会使我们的项目更具内聚性和可读性。</p>
<h2 id="11不要在created和watch中调用方法">11.不要在“created”和“watch”中调用方法</h2>
<p>Vue开发人员经常犯的一个错误是他们不必要地在created和watch中调用方法。 其背后的想法是，我们希望在组件初始化后立即运行watch。</p>
<pre><code class="language-c">// 不好的做法
created: () {
this.handleChange()
},
methods: {
handleChange() {
// stuff happens
}
},
watch () {
property() {
this.handleChange()
}
}
</code></pre>
<p>但是，Vue为此提供了内置的解决方案，这是我们经常忘记的Vue watch属性。</p>
<p>我们要做的就是稍微重组watch并声明两个属性：</p>
<p>1.handler (newVal, oldVal)-这是我们的watch方法本身。<br>
2. immediate: true– 代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行</p>
<pre><code class="language-c">// 好的做法
methods: {
  handleChange() {
    // stuff happens
  }
},
watch () {
  property {
    immediate: true
    handler() {
      this.handleChange()
    }
  }
}
</code></pre>
<h2 id="12-模板表达式应该只有基本的-js-表达式">12. 模板表达式应该只有基本的 JS 表达式</h2>
<p>在模板中添加尽可能多的内联功能是很自然的。但是这使得我们的模板不那么具有声明性，而且更加复杂，也让模板会变得非常混乱。</p>
<p>为此，让我们看看Vue样式指南中另一个规范化字符串的示例，看看它有多混乱。</p>
<pre><code class="language-c">//不好的做法
{{
  fullName.split(' ').map(function (word) {
    return word[0].toUpperCase() + word.slice(1)
  }).join(' ')
}}
</code></pre>
<p>基本上，我们希望模板中的所有内容都直观明了。 为了保持这一点，我们应该将复杂的表达式重构为适当命名的组件选项。</p>
<p>分离复杂表达式的另一个好处是可以重用这些值。</p>
<pre><code class="language-c">// 好的做法
{{ normalizedFullName }}
// The complex expression has been moved to a computed property
computed: {
  normalizedFullName: function () {
    return this.fullName.split(' ').map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
    }).join(' ')
  }
}
</code></pre>
<h2 id="13路由参数变化组件不更新">13.路由参数变化组件不更新</h2>
<p>同一 path 的页面跳转时路由参数变化，但是组件没有对应的更新。</p>
<p>原因：主要是因为获取参数写在了created 或者 mounted 路由钩子函数中，路由参数变化的时候，这个生命周期不会重新执行。</p>
<p>我们可以用watch 监听路由。</p>
<pre><code class="language-c">watch: {
 // 方法1  监听路由是否变化
  '$route' (to, from) { 
    if(to.query.id !== from.query.id){
    　　this.id = to.query.id;
    　　this.init();//重新加载数据
    }
  }
}
//方法2  设置路径变化时的处理函数
watch: {
'$route': {
    handler: 'init',
    immediate: true
  }
}
</code></pre>
<h2 id="14路由懒加载">14.路由懒加载</h2>
<p>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</p>
<pre><code class="language-c">// 1、Vue异步组件技术：
    {
        path: '/home',
        name: 'Home',
        component: resolve =&gt; reqire(['path路径'], resolve)
  }

// 2、es6提案的import()
  const Home = () =&gt; import('path路径')

// 3、webpack提供的require.ensure()
    {
        path: '/home',
        name: 'Home',
        component: r =&gt; require.ensure([],() =&gt;  r(require('path路径')), 'demo')
    }
</code></pre>
<h2 id="15自定义路径别名">15.自定义路径别名</h2>
<p>我们也可以在基础配置文件中添加自己的路径别名</p>
<pre><code class="language-c">resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
      'assets': resolve('src/assets')
    }
  }
</code></pre>
<p>然后我们导入组件的时候就可以这样写：</p>
<pre><code class="language-c">// import YourComponent from '/src/assets/YourComponent'
import YourComponent from 'assets/YourComponent'
</code></pre>
<p>这样既解决了路径过长的麻烦，又解决了相对路径的烦恼。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E5%A7%8B%E7%BB%88%E5%9C%A8-v-for-%E4%B8%AD%E4%BD%BF%E7%94%A8-key">1.始终在 v-for 中使用 :key</a></li>
<li><a href="#2%E5%9C%A8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D">2.在事件中使用短横线命名</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A3%B0%E6%98%8E-props%E5%B9%B6%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D%E6%9D%A5%E8%AE%BF%E9%97%AE-props">3.使用驼峰式声明 props，并在模板中使用短横线命名来访问 props</a></li>
<li><a href="#4data-%E5%BA%94%E5%A7%8B%E7%BB%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">4.data 应始终返回一个函数</a></li>
<li><a href="#5-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%90%8C%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8A%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8v-if%E5%92%8Cv-for%E6%8C%87%E4%BB%A4">5. 不要在同个元素上同时使用v-if和v-for指令</a></li>
<li><a href="#6%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%88%91%E4%BB%AC%E7%9A%84-props">6.用正确的定义验证我们的 props</a></li>
<li><a href="#7%E7%BB%84%E4%BB%B6%E5%85%A8%E5%90%8D%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E6%88%96%E6%88%96%E8%80%85%E7%9F%AD%E6%A8%AA%E7%BA%BF">7.组件全名使用驼峰或或者短横线</a></li>
<li><a href="#8-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E7%9B%B8%E5%BA%94%E5%9C%B0%E5%8A%A0%E4%B8%8A%E5%89%8D%E7%BC%80">8. 基本组件应该相应地加上前缀</a></li>
<li><a href="#9%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D%E5%BA%94%E8%AF%A5%E5%B8%A6%E6%9C%89%E5%89%8D%E7%BC%80-the">9.单实例组件命名应该带有前缀 The</a></li>
<li><a href="#10%E4%BF%9D%E6%8C%81%E6%8C%87%E4%BB%A4%E7%AE%80%E5%86%99%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">10.保持指令简写的一致性</a></li>
<li><a href="#11%E4%B8%8D%E8%A6%81%E5%9C%A8created%E5%92%8Cwatch%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">11.不要在“created”和“watch”中调用方法</a></li>
<li><a href="#12-%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E8%AF%A5%E5%8F%AA%E6%9C%89%E5%9F%BA%E6%9C%AC%E7%9A%84-js-%E8%A1%A8%E8%BE%BE%E5%BC%8F">12. 模板表达式应该只有基本的 JS 表达式</a></li>
<li><a href="#13%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E5%8F%98%E5%8C%96%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%9B%B4%E6%96%B0">13.路由参数变化组件不更新</a></li>
<li><a href="#14%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD">14.路由懒加载</a></li>
<li><a href="#15%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D">15.自定义路径别名</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dark-yifeng.github.io/post/vue-zhong-de-mo-ban-bian-yi-yuan-li/">
              <h3 class="post-title">
                Vue：内部运行机制
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  QQ:<a href="https://github.com/getgridea/gridea" target="_blank">1306045416</a>
  <a class="rss" href="https://dark-yifeng.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
